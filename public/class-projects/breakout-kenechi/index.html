 <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Breakout • Kenechi Edition</title>

<!-- Google Font -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<!-- Tone.js for SFX -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

<style>
  :root{
    --glow:#87fff7;
    --accent:#ffe066;
    --pink:#ff4dff;
    --bg1:#0f1020;
    --bg2:#1c0e3a;
    --bg3:#0d2b45;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    height:100svh;
    display:grid;
    place-items:center;
    background:
      radial-gradient(1200px 600px at 15% 30%, var(--bg2) 0%, transparent 60%),
      radial-gradient(800px 800px at 85% 70%, var(--bg3) 0%, transparent 55%),
      linear-gradient(160deg, #090a0f 0%, var(--bg1) 100%);
    color:#fff;
    font-family:'Press Start 2P', system-ui, sans-serif;
    overflow:hidden;
  }
  #game-container{
    text-align:center;
  }
  h1{
    margin:10px 0 12px;
    font-size:22px;
    letter-spacing:1px;
    color:var(--accent);
    text-shadow:2px 2px 0 #000, 0 0 14px var(--pink);
  }
  .subtitle{
    font-size:10px;
    opacity:.85;
    margin-bottom:10px;
  }
  canvas{
    background: linear-gradient(180deg, #050507 0%, #000 100%);
    border:4px solid #fff;
    border-radius:18px;
    box-shadow:0 0 20px #fff, 0 0 60px var(--glow) inset, 0 0 100px #000 inset;
  }
  .legend{
    margin-top:10px;
    font-size:10px;
    opacity:.85;
  }
  .pill{
    display:inline-block;
    padding:6px 10px;
    border:1px solid #fff3;
    border-radius:999px;
    margin:4px;
    background:#ffffff10;
    backdrop-filter: blur(3px);
  }
</style>
</head>
<body>
  <div id="game-container">
    <h1>Breakout • <span style="color:#4dff88;text-shadow:2px 2px 0 #000">Kenechi</span> Edition</h1>
    <div class="subtitle">Colorful • Juicy • With SFX & Power-Ups</div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="legend">
      <span class="pill">← → move</span>
      <span class="pill">P pause</span>
      <span class="pill">click/space launch</span>
    </div>
  </div>

<script>
/* =========================
   Canvas & Context
========================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

/* =========================
   Tone.js Sound Engine
========================= */
const wallHitSound  = new Tone.Synth({ oscillator:{type:'square'},  envelope:{attack:0.01,decay:0.08,sustain:0,release:0.06}}).toDestination();
const paddleSound   = new Tone.Synth({ oscillator:{type:'triangle'}, envelope:{attack:0.01,decay:0.08,sustain:0,release:0.06}}).toDestination();
const brickSound    = new Tone.Synth({ oscillator:{type:'sawtooth'}, envelope:{attack:0.01,decay:0.15,sustain:0.05,release:0.08}}).toDestination();
const loseLifeSound = new Tone.Synth({ oscillator:{type:'fmsine'},  envelope:{attack:0.05,decay:0.4,sustain:0,release:0.1}}).toDestination();
const powerSound    = new Tone.Synth({ oscillator:{type:'sine'},     envelope:{attack:0.005,decay:0.2,sustain:0,release:0.05}}).toDestination();
const pauseSound    = new Tone.MembraneSynth().toDestination();
const levelSound    = new Tone.Synth({ oscillator:{type:'square'},   envelope:{attack:0.005,decay:0.2,sustain:0,release:0.05}}).toDestination();

function sfxPlay(s, note='C4', dur='8n'){ try{ s.triggerAttackRelease(note, dur); }catch{} }

/* =========================
   Game State
========================= */
let score = 0;
let lives = 3;
let level = 1;
let gameOver = false;
let gameStarted = false;
let paused = false;
let awaitingLaunch = true; // when ball sticks to paddle or at start
const keys = {};

const UI = {
  colors:['#ff4d4d','#ff914d','#ffe74d','#6df06d','#4db8ff','#b84dff'],
}

/* =========================
   Game Objects
========================= */
const paddle = {
  baseWidth:120,
  width:120,
  height:20,
  x: canvas.width/2 - 60,
  y: canvas.height - 40,
  speed:8,
  dx:0,
  color:'#00ffff',
  outline:'#ffffff',
  draw(){
    // glossy gradient paddle
    const g = ctx.createLinearGradient(this.x, this.y, this.x, this.y+this.height);
    g.addColorStop(0, '#00ffff');
    g.addColorStop(1, '#007777');
    ctx.fillStyle = g;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    ctx.strokeStyle = this.outline;
    ctx.strokeRect(this.x, this.y, this.width, this.height);
  },
  update(){
    this.x += this.dx;
    if (this.x < 0) this.x = 0;
    if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

    // carry attached ball
    if (ball.attached){
      ball.x = this.x + this.width/2;
      ball.y = this.y - ball.size - 2;
    }
  }
};

const ball = {
  size:10,
  x: canvas.width/2,
  y: canvas.height/2+50,
  speed:4,
  dx: 4,
  dy:-4,
  color:'#ffff66',
  stickyOnce:false,   // power-up flag
  attached:false,     // currently stuck to paddle
  draw(){
    // neon ball
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 18;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.closePath();
  },
  update(){
    if (this.attached || paused) return;

    this.x += this.dx;
    this.y += this.dy;

    // wall collisions
    if (this.x + this.size > canvas.width || this.x - this.size < 0){
      this.dx *= -1;
      sfxPlay(wallHitSound, 'E4');
    }
    if (this.y - this.size < 0){
      this.dy *= -1;
      sfxPlay(wallHitSound, 'C4');
    }

    // paddle collision
    if (this.y + this.size >= paddle.y &&
        this.x >= paddle.x &&
        this.x <= paddle.x + paddle.width &&
        this.dy > 0){
      // hit position -> angle
      const hitPos = (this.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
      const angle = hitPos * (Math.PI/3); // up to 60°
      const speed = Math.hypot(this.dx, this.dy);
      this.dx = speed * Math.sin(angle);
      this.dy = -Math.abs(speed * Math.cos(angle));

      sfxPlay(paddleSound, 'G4');

      if (this.stickyOnce){
        this.attached = true;
        this.stickyOnce = false;
      }
    }

    // bottom -> lose life
    if (this.y - this.size > canvas.height){
      lives--;
      sfxPlay(loseLifeSound, 'C3', '4n');
      if (lives <= 0){
        gameOver = true;
        addScoreToLeaderboard(score);
      }else{
        resetBallToPaddle(true);
      }
    }
  }
};

/* =========================
   Bricks & Levels
========================= */
const brickInfo = {
  width:75,
  height:20,
  padding:10,
  offsetX:45,
  offsetY:60,
  colors: UI.colors
};
let bricks = [];

function createBricks(currentLevel){
  bricks = [];
  // Layouts
  const layouts = [
    {rows:5, cols:9, pattern:'grid'},
    {rows:6, cols:11, pattern:'pyramid'},
    {rows:6, cols:9, pattern:'alternate'}
  ];
  const layout = layouts[(currentLevel-1) % layouts.length];

  for (let r=0; r<layout.rows; r++){
    for (let c=0; c<layout.cols; c++){
      let create = true;

      if (layout.pattern === 'pyramid'){
        const count = r*2+1;
        const start = Math.floor((layout.cols - count)/2);
        if (c < start || c > start+count-1) create = false;
      }
      if (layout.pattern === 'alternate'){
        if (r % 2 !== 0 && c % 2 !== 0) create = false;
      }

      if (create){
        const x = c * (brickInfo.width + brickInfo.padding) + brickInfo.offsetX;
        const y = r * (brickInfo.height + brickInfo.padding) + brickInfo.offsetY;
        bricks.push({
          x, y,
          width:brickInfo.width,
          height:brickInfo.height,
          color: brickInfo.colors[r % brickInfo.colors.length]
        });
      }
    }
  }
}

/* =========================
   Power-Ups
========================= */
const POWER_TYPES = {
  WIDE: 'WIDE',
  SLOW: 'SLOW',
  STICKY: 'STICKY'
};
let powerUps = []; // {x,y,vy,size,type,color}

function maybeSpawnPowerUp(brick){
  const chance = 0.25; // 25% chance
  if (Math.random() < chance){
    const typePick = Math.random();
    const type = typePick < 0.34 ? POWER_TYPES.WIDE
               : typePick < 0.67 ? POWER_TYPES.SLOW
               : POWER_TYPES.STICKY;
    const color = type === POWER_TYPES.WIDE ? '#4dff88'
                : type === POWER_TYPES.SLOW ? '#66a3ff'
                : '#ff66ff';
    powerUps.push({
      x: brick.x + brick.width/2,
      y: brick.y + brick.height/2,
      vy: 2 + Math.random()*1.5,
      size: 10,
      type, color
    });
  }
}

function drawPowerUps(){
  powerUps.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.fill();
    ctx.closePath();

    // icon letter
    ctx.fillStyle = '#000';
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(p.type[0], p.x, p.y+3);
  });
}

function updatePowerUps(){
  powerUps.forEach(p => p.y += p.vy);
  // collect or drop off-screen
  for (let i = powerUps.length-1; i>=0; i--){
    const p = powerUps[i];
    // caught by paddle?
    if (p.y + p.size >= paddle.y &&
        p.x >= paddle.x &&
        p.x <= paddle.x + paddle.width){
      triggerPowerUp(p.type);
      powerUps.splice(i,1);
      sfxPlay(powerSound, 'C5');
      continue;
    }
    // off screen
    if (p.y - p.size > canvas.height){
      powerUps.splice(i,1);
    }
  }
}

function triggerPowerUp(type){
  if (type === POWER_TYPES.WIDE){
    const original = paddle.width;
    paddle.width = Math.min(paddle.width + 80, 260);
    setTimeout(()=>{ paddle.width = original; }, 8000);
  }else if (type === POWER_TYPES.SLOW){
    scaleBallSpeed(0.6);
    setTimeout(()=> scaleBallSpeed(1/0.6), 8000);
  }else if (type === POWER_TYPES.STICKY){
    ball.stickyOnce = true; // next paddle hit sticks
  }
}

function scaleBallSpeed(mult){
  const speed = Math.hypot(ball.dx, ball.dy);
  const nx = (ball.dx / speed) * (speed*mult);
  const ny = (ball.dy / speed) * (speed*mult);
  ball.dx = nx;
  ball.dy = ny;
}

/* =========================
   Collisions with Bricks
========================= */
function checkBrickCollisions(){
  for (let i = bricks.length-1; i >= 0; i--){
    const b = bricks[i];
    if (ball.x + ball.size > b.x &&
        ball.x - ball.size < b.x + b.width &&
        ball.y + ball.size > b.y &&
        ball.y - ball.size < b.y + b.height){

      // Reflect on the side we hit more
      const overlapX = (ball.x < b.x) ? (ball.x + ball.size - b.x) : ((b.x + b.width) - (ball.x - ball.size));
      const overlapY = (ball.y < b.y) ? (ball.y + ball.size - b.y) : ((b.y + b.height) - (ball.y - ball.size));
      if (overlapX < overlapY) {
        ball.dx *= -1;
      } else {
        ball.dy *= -1;
      }

      bricks.splice(i,1);
      score += 100;
      sfxPlay(brickSound, 'A5');

      maybeSpawnPowerUp(b);

      if (bricks.length === 0) {
        nextLevel();
      }
    }
  }
}

/* =========================
   Levels, Reset, Pause
========================= */
function resetBallToPaddle(keepSpeed=false){
  ball.attached = true;
  awaitingLaunch = true;
  ball.x = paddle.x + paddle.width/2;
  ball.y = paddle.y - ball.size - 2;
  if (!keepSpeed){
    ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
    ball.dy = -ball.speed;
  }
}

function nextLevel(){
  level++;
  score += 500;
  ball.speed += 0.5;
  createBricks(level);
  powerUps = [];
  resetBallToPaddle(false);
  sfxPlay(levelSound, 'C5'); setTimeout(()=>sfxPlay(levelSound,'E5'), 60); setTimeout(()=>sfxPlay(levelSound,'G5'), 120);
}

function togglePause(){
  paused = !paused;
  sfxPlay(pauseSound, paused ? 'C2' : 'G2', '16n');
}

/* =========================
   Drawing
========================= */
function drawUI(){
  ctx.fillStyle = '#fff';
  ctx.font = '16px "Press Start 2P"';
  ctx.textAlign = 'left';
  ctx.fillText(`Score: ${score}`, 20, 30);

  ctx.textAlign = 'center';
  ctx.fillText(`Level: ${level}`, canvas.width/2, 30);

  ctx.textAlign = 'right';
  ctx.fillText(`Lives: ${lives}`, canvas.width-20, 30);

  // credit
  ctx.font = '10px "Press Start 2P"';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#8fffd0';
  ctx.fillText('by Kenechi', 20, canvas.height-12);
}

function drawBricks(){
  bricks.forEach(brick => {
    const g = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y+brick.height);
    g.addColorStop(0, '#ffffffaa');
    g.addColorStop(0.35, brick.color);
    g.addColorStop(1, '#000');
    ctx.fillStyle = g;
    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
    ctx.strokeStyle = '#00000066';
    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
  });
}

function drawStartScreen(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawLeaderboard( true );
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.font = '42px "Press Start 2P"';
  ctx.fillText('BREAKOUT', canvas.width/2, canvas.height/2 - 90);
  ctx.font = '18px "Press Start 2P"';
  ctx.fillText('Click to Start', canvas.width/2, canvas.height/2 - 40);
  ctx.fillText('Use Arrow Keys to Move', canvas.width/2, canvas.height/2 + 10);
  ctx.fillStyle = '#ffe066';
  ctx.fillText('P to Pause • Space to Launch', canvas.width/2, canvas.height/2 + 50);
}

function drawPaused(){
  if (!paused) return;
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#ff66ff';
  ctx.textAlign = 'center';
  ctx.font = '48px "Press Start 2P"';
  ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
}

function drawGameOverScreen(){
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#ff4d4d';
  ctx.textAlign = 'center';
  ctx.font = '46px "Press Start 2P"';
  ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 60);
  ctx.fillStyle = '#fff';
  ctx.font = '22px "Press Start 2P"';
  ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 - 10);
  drawLeaderboard(false);
  ctx.fillStyle = '#ffe066';
  ctx.font = '18px "Press Start 2P"';
  ctx.fillText('Click to Play Again', canvas.width/2, canvas.height/2 + 140);
}

/* =========================
   Leaderboard (Top 5)
========================= */
const LB_KEY = 'breakoutHighScoresV2';
function getLeaderboard(){
  try{
    const raw = localStorage.getItem(LB_KEY);
    return raw ? JSON.parse(raw) : [];
  }catch{ return []; }
}
function setLeaderboard(arr){
  try{ localStorage.setItem(LB_KEY, JSON.stringify(arr)); }catch{}
}
function addScoreToLeaderboard(sc){
  const lb = getLeaderboard();
  // check if qualifies (always prompt once to let them add name if top 5 or list not full)
  const qualifies = lb.length < 5 || sc > lb[lb.length-1].score;
  if (!qualifies) return;

  let initials = (prompt('New High Score! Enter your initials (max 3):', 'AAL') || '???').toUpperCase();
  initials = initials.replace(/[^A-Z0-9]/g,'').slice(0,3) || '???';

  lb.push({ name: initials, score: sc, date: new Date().toISOString().slice(0,10) });
  lb.sort((a,b)=> b.score - a.score);
  setLeaderboard(lb.slice(0,5));
}

function drawLeaderboard(isStart){
  const lb = getLeaderboard();
  const x = canvas.width/2;
  const y = isStart ? canvas.height/2 + 90 : canvas.height/2 + 30;

  ctx.textAlign = 'center';
  ctx.fillStyle = '#8fffd0';
  ctx.font = '18px "Press Start 2P"';
  ctx.fillText('Top 5', x, y);

  ctx.font = '14px "Press Start 2P"';
  ctx.fillStyle = '#fff';
  if (lb.length === 0){
    ctx.fillText('— none yet —', x, y + 24);
  } else {
    lb.forEach((it, i)=>{
      const line = `${i+1}. ${it.name.padEnd(3,' ')}  ${String(it.score).padStart(5,' ')}`;
      ctx.fillText(line, x, y + 24 + i*22);
    });
  }
}

/* =========================
   Game Flow
========================= */
function resetGame(){
  score = 0;
  lives = 3;
  level = 1;
  gameOver = false;
  powerUps = [];
  createBricks(level);
  paddle.width = paddle.baseWidth;
  resetBallToPaddle(false);
  gameStarted = true;
  paused = false;
  loop(); // make sure it runs immediately
}

/* =========================
   Main Loop
========================= */
function loop(){
  if (!gameStarted){
    drawStartScreen();
    return;
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // updates
  if (!paused && !gameOver){
    paddle.update();
    ball.update();
    updatePowerUps();
    checkBrickCollisions();
  }

  // draws
  drawBricks();
  drawPowerUps();
  paddle.draw();
  ball.draw();
  drawUI();
  drawPaused();

  if (gameOver){
    drawGameOverScreen();
    return; // stop animating further until click
  }

  requestAnimationFrame(loop);
}

/* =========================
   Input
========================= */
function onKeyDown(e){
  if (e.key === 'ArrowRight' || e.key === 'Right') paddle.dx = paddle.speed;
  else if (e.key === 'ArrowLeft' || e.key === 'Left') paddle.dx = -paddle.speed;
  else if (e.key.toLowerCase() === 'p') togglePause();
  else if (e.code === 'Space'){
    if (Tone.context.state !== 'running') Tone.start();
    if (ball.attached){
      ball.attached = false;
      awaitingLaunch = false;
      if (ball.dy === 0) ball.dy = -ball.speed;
    }
    if (!gameStarted) { resetGame(); }
  }
}
function onKeyUp(e){
  if (['ArrowRight','Right','ArrowLeft','Left'].includes(e.key)) paddle.dx = 0;
}

window.addEventListener('keydown', onKeyDown);
window.addEventListener('keyup', onKeyUp);

// Start / restart on click
canvas.addEventListener('click', ()=>{
  if (Tone.context.state !== 'running') Tone.start();

  if (!gameStarted || gameOver){
    resetGame();
    return;
  }
  if (ball.attached){
    ball.attached = false;
    awaitingLaunch = false;
    if (ball.dy === 0) ball.dy = -ball.speed;
  }
});

/* =========================
   Boot
========================= */
createBricks(level);
drawStartScreen();
</script>
</body>
</html>
