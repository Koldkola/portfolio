<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kenechi Obiozor | Portfolio & Archive</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/styles.css" />
  <style>
    /* Home page tooltip overrides */
    .tooltip-popup {
      position: fixed;
      bottom: auto;
      min-width: 320px;
      max-width: 400px;
    }
  </style>
</head>
<body>
  <div class="ambient-bg"></div>

  <header class="site-header">
    <nav class="nav">
      <a class="logo" href="/">Kumachi.</a>
      <ul class="nav-links">
        <li><a href="/projects.html"> Projects</a></li>
        <li><a href="/archive.html">Archive</a></li>
        <li><a href="/resume.html">Resume</a></li>
        <li><a href="/contact.html">Contact</a></li>
      </ul>
    </nav>
    <div class="site-search">
      <input id="siteSearch" type="search" placeholder="Search my portfolio..." aria-label="Search my portfolio" />
      <div id="siteSearchResults" class="site-search-results" role="listbox" aria-label="Search results"></div>
    </div>
    <div class="tooltip-hint">üí° <span class="tooltip-hint-text">Hover over <span style="color: #a855f7; font-weight: 600;">underlined words</span> to learn more</span></div>
  </header>

  <main>
    <section class="hero">
      <div class="hero-content">
        <p class="eyebrow">Creative Technologist / Wannabe Curator / Nerd of Sorts</p>
                <p2 class="sub"> <h1 id="kumachi-title"> <span class="italic-art">Kumachi's Korner</span></h1></p2>
        <div class="hero-cta">
          <a class="glass-btn btn-15" href="/projects.html">View Tech Projects</a>
          <a class="glass-btn btn-9" href="/archive.html">Explore my Archive</a>
        </div>
      </div>
      
      <!-- Right side interactive elements -->
      <div class="hero-right">
        <!-- Interactive Globe -->
        <h3 style="text-align: center; margin-bottom: 20px; font-family: 'Playfair Display', serif; font-style: italic; font-size: 2.5rem; color: var(--text-primary);">
          Whats in <span id="your-text">your</span> <span class="tooltip-word" style="text-decoration: underline; text-decoration-color: var(--accent-gaming);">Korner<span class="tooltip-popup">share with others and see whats going on</span></span>?
        </h3>
        <div class="globe-container" id="globeContainer">
          <div class="globe" id="globe">
            <div class="globe-prompt">It's just you</div>
          </div>
          <button class="globe-add-btn" id="globeAddBtn" title="Add your thoughts">+</button>
        </div>
      </div>
    </section>

    <section id="interface" class="mirror-section">
      <div class="section-header interactive-header">
        <h2 id="kommunity-kamera-title">Kommunity Kamera</h2>
        <p>Something to play around with.</p>
      </div>
      
      <div class="mirror-container glass-panel">
        
        <div class="canvas-wrapper">
          <video id="webcam" width="640" height="480" autoplay playsinline style="display: none;"></video>
          <canvas id="mirror-canvas" width="640" height="480"></canvas>
        </div>

        <div class="mirror-side-controls">
          <div class="mode-buttons-vertical">
            <button class="ctrl-btn active" data-mode="wireframe">Neon</button>
            <button class="ctrl-btn" data-mode="thermal">Thermal</button>
            <button class="ctrl-btn" data-mode="zeroday">Normal</button>
            <button class="ctrl-btn" data-mode="temporal">Lag</button>
            <button class="ctrl-btn" data-mode="watercolor">Watercolor</button>
            <button class="ctrl-btn" data-mode="constellation">Constellation</button>
          </div>

          <div class="color-palette-section">
            <div class="color-swatches" id="colorSwatches">
              <div class="color-swatch" style="background: #ccc;" title="Loading..."></div>
              <div class="color-swatch" style="background: #ccc;" title="Loading..."></div>
              <div class="color-swatch" style="background: #ccc;" title="Loading..."></div>
              <div class="color-swatch" style="background: #ccc;" title="Loading..."></div>
              <div class="color-swatch" style="background: #ccc;" title="Loading..."></div>
            </div>
          </div>

          <div class="camera-shutter-wrapper">
            <div class="camera-toggle-row">
              <button id="webcam-toggle" class="webcam-toggle-btn" title="Start or stop webcam">START CAMERA</button>
              <button id="flip-camera-btn" class="flip-camera-btn" title="Flip camera" style="display: none;">üîÑ</button>
            </div>
            <div class="capture-row">
              <button id="capture-btn" class="shutter-btn" title="Capture Archive"></button>
              <button id="record-btn" class="record-btn" title="Record Clip">REC</button>
            </div>
            <span id="record-timer" class="record-timer hidden">00:00</span>
            <span class="shutter-label">CAPTURE</span>
            <button id="snap-to-board-btn" class="snap-board-btn" title="Snap photo and post to Kommunity Korner"> POST TO KOMMUNITY</button>
            <button id="video-message-btn" class="feature-btn" title="Record 5-15 second video message">VIDEO TO KOMMUNITY</button>
            <button id="photobooth-btn" class="feature-btn" title="Auto-capture photos every 5 seconds"> PHOTOBOOTH</button>
          </div>
        </div>
        
        <!-- Photobooth Grid Display -->
        <div id="photobooth-panel" class="photobooth-panel hidden">
          <div class="photobooth-header">
            <h3>Photobooth</h3>
            <div class="photobooth-actions">
              <button id="download-photobooth" class="btn secondary">Download Grid</button>
              <button id="clear-photobooth" class="btn secondary">Clear</button>
            </div>
          </div>
          <div id="photobooth-grid" class="photobooth-grid"></div>
        </div>
        
      </div>
    </section>

    <section class="weekly-section">
      <div class="interactive-header">
        <h2>Whats in <span id="my-text">my</span> <span class="tooltip-word">Korner<span class="tooltip-popup">Things i resonated with over the week</span></span>?</h2>
        <div class="week-controls">
          <button class="ctrl-btn" id="prev-btn" aria-label="Previous week">‚Üê</button>
          <span id="week-label"></span>
          <button class="ctrl-btn" id="next-btn" aria-label="Next week">‚Üí</button>
          <button class="board-admin-btn" id="weeklyAdminBtn" title="Weekly admin mode (Auto-locks when editor closes)" type="button">üîí</button>
        </div>
      </div>
      <div id="weekly-grid" class="weekly-grid"></div>
    </section>
  </main>

  <!-- Category Detail Modal -->
  <div id="category-modal" class="category-modal">
    <div class="category-modal-content">
      <div class="sticky-tape" style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); width: 60px; height: 8px; background: rgba(0,0,0,0.2); border-radius: 3px; z-index: 10;"></div>
      <div class="category-modal-header">
        <h2 id="modal-title"></h2>
        <button class="category-modal-close" onclick="closeCategoryModal()" aria-label="Close modal">&times;</button>
      </div>
      <div class="category-modal-meta">
        <span id="modal-category"></span>
        <span id="modal-week"></span>
      </div>
      <div class="category-modal-body">
        <p id="modal-intro"></p>
        <div id="modal-highlights"></div>
        <div id="modal-inspiration"></div>
        <div id="modal-tools"></div>
      </div>
    </div>
  </div>

  <!-- Weekly Admin Password Modal -->
  <div id="weekly-admin-modal" class="category-modal">
    <div class="category-modal-content" style="max-width: 520px;">
      <div class="category-modal-header">
        <h2>Weekly Admin Access</h2>
        <button class="category-modal-close" onclick="closeWeeklyAdminModal()" aria-label="Close modal">&times;</button>
      </div>
      <div class="category-modal-body">
        <form id="weekly-admin-form">
          <div class="form-group">
            <label for="weeklyAdminPassword">Enter admin password</label>
            <input type="password" id="weeklyAdminPassword" required placeholder="Password" />
            <div id="weekly-admin-error" style="color: #ff4444; font-size: 0.85rem; margin-top: 8px; display: none;">Incorrect password</div>
          </div>
          <button type="submit" class="btn primary">Unlock Weekly Admin</button>
        </form>
        
        <div id="weekly-label-settings" style="display: none; margin-top: 24px; padding-top: 24px; border-top: 1px solid var(--glass-border);">
          <h3 style="margin-bottom: 16px; color: var(--text-primary);">Customize Field Labels</h3>
          
          <div class="form-group">
            <label for="labelIntro">Intro Label</label>
            <input type="text" id="labelIntro" placeholder="Intro" />
          </div>
          
          <div class="form-group">
            <label for="labelHighlights">Highlights Label</label>
            <input type="text" id="labelHighlights" placeholder="Key Highlights" />
          </div>
          
          <div class="form-group">
            <label for="labelInspiration">Inspiration Label</label>
            <input type="text" id="labelInspiration" placeholder="Inspiration" />
          </div>
          
          <div class="form-group">
            <label for="labelTools">Tools/Resources Label</label>
            <input type="text" id="labelTools" placeholder="Tools & Resources" />
          </div>
          
          <button type="button" class="btn primary" onclick="saveWeeklyLabels()">Save Labels</button>
          <button type="button" class="btn secondary" onclick="resetWeeklyLabels()">Reset to Default</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Weekly Editor Modal -->
  <div id="weekly-editor-modal" class="category-modal">
    <div class="category-modal-content" style="max-width: 900px;">
      <div class="category-modal-header">
        <h2>Weekly Highlights Editor</h2>
        <button class="category-modal-close" onclick="closeWeeklyEditor()" aria-label="Close modal">&times;</button>
      </div>
      <div class="category-modal-body">
        <div class="form-row">
          <div class="form-group">
            <label for="weeklyWeekSelect">Week</label>
            <select id="weeklyWeekSelect"></select>
          </div>
          <div class="form-group">
            <label for="weeklyWeekDate">Add new week (start date)</label>
            <div style="display: flex; gap: 8px;">
              <input type="date" id="weeklyWeekDate" />
              <button type="button" class="btn secondary" id="addWeekBtn">Add Week</button>
            </div>
          </div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label for="weeklyCategory">Category</label>
            <input type="text" id="weeklyCategory" placeholder="Music / Art / Fashion" />
          </div>
          <div class="form-group">
            <label for="weeklyTitle">Title</label>
            <input type="text" id="weeklyTitle" placeholder="Title" />
          </div>
        </div>

        <div class="form-group">
          <label for="weeklyDescription">Description (HTML allowed for links/images)</label>
          <textarea id="weeklyDescription" rows="3" placeholder="Short description"></textarea>
        </div>

        <div class="form-group">
          <label for="weeklyImage">Image URLs (up to 4, one per line)</label>
          <textarea id="weeklyImage" rows="3" placeholder="https://"></textarea>
        </div>

        <div class="form-group">
          <label for="weeklyPhoto">Photo Uploads (optional, up to 4)</label>
          <input type="file" id="weeklyPhoto" accept="image/*" multiple />
        </div>

        <div class="form-group">
          <label for="weeklyVideo">Video URLs (optional, up to 4, one per line - YouTube, Vimeo, Twitter/X, direct links)</label>
          <textarea id="weeklyVideo" rows="3" placeholder="https://youtube.com/watch?v=..."></textarea>
        </div>

        <div class="form-group">
          <label for="weeklyVideoUpload">Video Uploads (optional, up to 4)</label>
          <input type="file" id="weeklyVideoUpload" accept="video/*" multiple />
        </div>

        <div class="form-group">
          <label for="weeklyIntro">Intro (HTML allowed)</label>
          <div class="textarea-wrapper">
            <textarea id="weeklyIntro" rows="3" placeholder="Intro text"></textarea>
            <button type="button" class="emoji-btn" data-target="weeklyIntro" title="Add emoji">üòä</button>
          </div>
        </div>

        <div class="form-group">
          <label for="weeklyHighlights">Key Highlights (one per line, HTML allowed)</label>
          <div class="textarea-wrapper">
            <textarea id="weeklyHighlights" rows="4" placeholder="Highlight 1\nHighlight 2"></textarea>
            <button type="button" class="emoji-btn" data-target="weeklyHighlights" title="Add emoji">üòä</button>
          </div>
        </div>

        <div class="form-group">
          <label for="weeklyInspiration">Inspiration (HTML allowed)</label>
          <div class="textarea-wrapper">
            <textarea id="weeklyInspiration" rows="3" placeholder="Inspiration"></textarea>
            <button type="button" class="emoji-btn" data-target="weeklyInspiration" title="Add emoji">üòä</button>
          </div>
        </div>

        <div class="form-group">
          <label for="weeklyTools">Tools & Resources (HTML allowed)</label>
          <div class="textarea-wrapper">
            <textarea id="weeklyTools" rows="3" placeholder="Tools"></textarea>
            <button type="button" class="emoji-btn" data-target="weeklyTools" title="Add emoji">üòä</button>
          </div>
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button type="button" class="btn secondary" id="weeklyDeleteBtn" style="display: none;">Delete</button>
          <button type="button" class="btn secondary" onclick="closeWeeklyEditor()">Cancel</button>
          <button type="button" class="btn primary" id="weeklySaveBtn">Save</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Globe Submission Modal -->
  <div id="globe-modal" class="category-modal">
    <div class="category-modal-content">
      <div class="category-modal-header">
        <h2>It's just you</h2>
        <button class="category-modal-close" onclick="closeGlobeModal()" aria-label="Close modal">&times;</button>
      </div>
      <div class="category-modal-body">
        <form id="globe-form">
          <div class="form-group">
            <label for="userName">Nickname</label>
            <input type="text" id="userName" required placeholder="Enter your name or initials" maxlength="30" />
          </div>
          
          <div class="form-group">
            <label for="weekFeeling"> If you feel like it, you can leave something too.</label>
            <div class="textarea-wrapper">
              <textarea id="weekFeeling" required placeholder="Share your thoughts..." rows="4"></textarea>
              <button type="button" class="emoji-btn" data-target="weekFeeling" title="Add emoji">üòä</button>
            </div>
          </div>
          
          <div class="form-group">
            <label for="userPhoto">Add a photo (optional)</label>
            <input type="file" id="userPhoto" accept="image/*" />
          </div>

          <div class="form-group">
            <label for="userVideo">Or add a video (optional, 5-15 seconds recommended)</label>
            <input type="file" id="userVideo" accept="video/*" />
            <p style="font-size: 0.75rem; opacity: 0.7; margin-top: 4px;">Note: Choose either photo or video, not both</p>
          </div>

          <div class="form-group">
            <label>Draw something! (optional)</label>
            <div class="drawing-controls">
              <input type="color" id="drawColor" value="#000000" title="Drawing color" />
              <button type="button" class="btn secondary" id="clearCanvasBtn">Clear</button>
              <button type="button" class="btn secondary" id="useDrawingBtn">Use Drawing</button>
              <span style="font-size: 0.75rem; opacity: 0.8; margin-left: 8px; white-space: nowrap;">‚Üê Click to save drawing</span>
            </div>
            <canvas id="drawingCanvas" width="300" height="200" style="border: 2px dashed var(--glass-border); border-radius: 8px; background: #ffffff; cursor: crosshair; display: block; margin: 10px 0; touch-action: none;"></canvas>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label for="textColor">Text Color</label>
              <input type="color" id="textColor" value="#ff1493" />
            </div>
            
            <div class="form-group">
              <label for="bgColor">Background Color</label>
              <input type="color" id="bgColor" value="#000000" />
            </div>
          </div>

          <div class="form-group">
            <label for="userFont">Font Style</label>
            <select id="userFont">
              <option value="Arial, sans-serif" style="font-family: Arial, sans-serif; font-weight: normal;">Arial</option>
              <option value="'Courier New', monospace" style="font-family: 'Courier New', monospace; font-weight: normal;">Courier New</option>
              <option value="Georgia, serif" style="font-family: Georgia, serif; font-weight: normal;">Georgia</option>
              <option value="'Times New Roman', serif" style="font-family: 'Times New Roman', serif; font-weight: normal;">Times New Roman</option>
              <option value="'Comic Sans MS', cursive" style="font-family: 'Comic Sans MS', cursive; font-weight: normal;">Comic Sans üòÑ</option>
              <option value="'Impact', sans-serif" style="font-family: 'Impact', sans-serif; font-weight: 900;">IMPACT</option>
              <option value="'Trebuchet MS', sans-serif" style="font-family: 'Trebuchet MS', sans-serif; font-weight: normal;">Trebuchet MS</option>
              <option value="'Brush Script MT', cursive" style="font-family: 'Brush Script MT', cursive; font-weight: normal; font-style: italic;">Brush Script</option>
              <option value="'Courier New', monospace" style="font-family: 'Courier New', monospace; font-weight: normal;">Typewriter</option>
              <option value="'Palatino Linotype', serif" style="font-family: 'Palatino Linotype', Palatino, serif; font-weight: normal;">Palatino</option>
              <option value="'Lucida Console', monospace" style="font-family: 'Lucida Console', Monaco, monospace; font-weight: normal;">Lucida Console</option>
              <option value="'Verdana', sans-serif" style="font-family: Verdana, sans-serif; font-weight: normal;">Verdana</option>
              <option value="'Garamond', serif" style="font-family: Garamond, serif; font-weight: normal; font-style: italic;">Garamond</option>
              <option value="'Papyrus', cursive" style="font-family: Papyrus, cursive; font-weight: normal;">Papyrus üåø</option>
              <option value="'Bad Unicorn', fantasy" style="font-family: 'Bad Unicorn', fantasy; font-weight: normal;">Bad Unicorn ü¶Ñ</option>
              <option value="'Bajareczka', cursive" style="font-family: 'Bajareczka', cursive; font-weight: normal;">Bajareczka ‚ú®</option>
              <option value="'Bajareczka Shadow', cursive" style="font-family: 'Bajareczka Shadow', cursive; font-weight: normal;">Bajareczka Shadow üëª</option>
              <option value="'Bananas', cursive" style="font-family: 'Bananas', cursive; font-weight: normal; font-style: italic;">Bananas üçå</option>
              <option value="'Biloxi Script', cursive" style="font-family: 'Biloxi Script', cursive; font-weight: normal;">Biloxi Script üé≠</option>
              <option value="'Cookie Monster', fantasy" style="font-family: 'Cookie Monster', fantasy; font-weight: normal;">Cookie Monster üç™</option>
              <option value="'Darlington', cursive" style="font-family: 'Darlington', cursive; font-weight: normal;">Darlington üé©</option>
              <option value="'Feijoada', fantasy" style="font-family: 'Feijoada', fantasy; font-weight: normal;">Feijoada üé®</option>
              <option value="'Flight of the Ocean', cursive" style="font-family: 'Flight of the Ocean', cursive; font-weight: normal;">Flight of the Ocean üåä</option>
              <option value="'Halimun', cursive" style="font-family: 'Halimun', cursive; font-weight: normal;">Halimun ‚òÅÔ∏è</option>
              <option value="'Hello Ketta', cursive" style="font-family: 'Hello Ketta', cursive; font-weight: normal;">Hello Ketta üëã</option>
              <option value="'Honeybee', cursive" style="font-family: 'Honeybee', cursive; font-weight: normal;">Honeybee üêù</option>
              <option value="'Koenigsberg', fantasy" style="font-family: 'Koenigsberg', fantasy; font-weight: normal;">Koenigsberg üè∞</option>
              <option value="'Lovely Home', cursive" style="font-family: 'Lovely Home', cursive; font-weight: normal;">Lovely Home üè°</option>
              <option value="'Oogie Boogie', fantasy" style="font-family: 'Oogie Boogie', fantasy; font-weight: normal;">Oogie Boogie üéÉ</option>
              <option value="'Sweet Getaway', cursive" style="font-family: 'Sweet Getaway', cursive; font-weight: normal;">Sweet Getaway üå¥</option>
              <option value="'Tiki Tropic', fantasy" style="font-family: 'Tiki Tropic', fantasy; font-weight: normal;">Tiki Tropic üóø</option>
              <option value="'Tiki Tropic Bold', fantasy" style="font-family: 'Tiki Tropic Bold', fantasy; font-weight: bold;">Tiki Tropic Bold üóø</option>
              <option value="'Tiki Tropic Outline', fantasy" style="font-family: 'Tiki Tropic Outline', fantasy; font-weight: normal;">Tiki Tropic Outline üóø</option>
              <option value="'Tomatoes', cursive" style="font-family: 'Tomatoes', cursive; font-weight: normal;">Tomatoes üçÖ</option>
              <option value="'Wedding Day', cursive" style="font-family: 'Wedding Day', cursive; font-weight: normal;">Wedding Day üíí</option>
              <option value="'Xiomara', cursive" style="font-family: 'Xiomara', cursive; font-weight: normal;">Xiomara üí´</option>
              <option value="'Yokelvision', fantasy" style="font-family: 'Yokelvision', fantasy; font-weight: normal;">Yokelvision üì∫</option>
            </select>
          </div>
          
          <button type="submit" class="btn primary">Add to Board</button>
        </form>
      </div>
    </div>
  </div>

  <!-- Globe Board View Modal -->
  <div id="globe-view-modal" class="board-modal">
    <div class="board-modal-content">
      <div class="category-modal-header">
        <h2 id="board-title">Kommunity Korner </h2>
        <div style="display: flex; align-items: center; gap: 16px;">
          <button class="board-delete-btn" id="boardDeleteBtn" title="Admin: Manage entries" style="display: none;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px;">
              <path d="M3 6h18M8 6V4a1 1 0 011-1h6a1 1 0 011 1v2M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
              <path d="M10 11v6M14 11v6"/>
            </svg>
          </button>
          <button class="board-admin-btn" id="boardAdminBtn" title="Admin mode (Auto-locks when board closes)">
            üîí
          </button>
          <button class="category-modal-close" onclick="closeGlobeViewModal()" aria-label="Close modal">&times;</button>
        </div>
      </div>
      <div id="board-admin-controls" style="display: none; margin-bottom: 20px; padding: 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid var(--accent-gaming); border-radius: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span style="color: var(--text-primary);">Admin Mode Active</span>
          <div style="display: flex; gap: 12px;">
            <button class="btn secondary" id="selectAllBtn" style="padding: 8px 16px; font-size: 0.85rem;">Select All</button>
            <button class="btn primary" id="deleteSelectedBtn" style="padding: 8px 16px; font-size: 0.85rem;">Delete Selected</button>
          </div>
        </div>
      </div>
      <div class="board-container" id="globe-view-content">
        <!-- Content populated by JavaScript -->
      </div>
    </div>
  </div>

  <!-- Admin Password Modal -->
  <div id="admin-password-modal" class="category-modal">
    <div class="category-modal-content" style="max-width: 500px;">
      <div class="category-modal-header">
        <h2>Admin Access</h2>
        <button class="category-modal-close" onclick="closeAdminPasswordModal()" aria-label="Close modal">&times;</button>
      </div>
      <div class="category-modal-body">
        <form id="admin-password-form">
          <div class="form-group">
            <label for="adminPassword">Enter admin password</label>
            <input type="password" id="adminPassword" required placeholder="Password" />
            <div id="admin-password-error" style="color: #ff4444; font-size: 0.85rem; margin-top: 8px; display: none;">Incorrect password</div>
          </div>
          <button type="submit" class="btn primary">Unlock Admin Mode</button>
        </form>
      </div>
    </div>
  </div>

  <!-- Photo Enlargement Modal -->
  <div id="photo-modal" class="photo-modal">
    <button class="photo-modal-close" onclick="closePhotoModal()" aria-label="Close">&times;</button>
    <img id="photo-modal-img" src="" alt="Enlarged photo" />
  </div>

  <!-- Snap to Board Quick Post Modal -->
  <div id="snap-to-board-modal" class="category-modal">
    <div class="category-modal-content" style="max-width: 600px;">
      <div class="category-modal-header">
        <h2>Post to Kommunity Korner</h2>
        <button class="category-modal-close" onclick="closeSnapToBoardModal()" aria-label="Close modal">&times;</button>
      </div>
      <div class="category-modal-body">
        <div style="display: flex; gap: 16px;">
          <div style="flex: 1;">
            <img id="snap-preview-img" src="" alt="Preview" style="width: 100%; border-radius: 8px; border: 2px solid var(--accent-gaming); background: #000; display: block;" />
            <video id="snap-preview-video" controls style="width: 100%; border-radius: 8px; border: 2px solid var(--accent-gaming); background: #000; display: none;"></video>
          </div>
          <form id="snap-post-form" style="flex: 1; display: flex; flex-direction: column; gap: 12px;">
            <!-- Auto-add checkbox -->
            <div style="display: flex; align-items: center; gap: 8px; padding: 12px; background: rgba(168, 85, 247, 0.1); border: 1px solid var(--accent-gaming); border-radius: 6px;">
              <input type="checkbox" id="autoAddCheckbox" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent-gaming);" />
              <label for="autoAddCheckbox" style="cursor: pointer; color: var(--accent-gaming); font-weight: 500; margin: 0; flex: 1;">
                ‚úì Anonymous add to Kommunity Korner
              </label>
            </div>

            <!-- Manual form (hidden when auto-add checked) -->
            <div id="manual-form-section">
              <div class="form-group">
                <label for="snapName">Your Name</label>
                <input type="text" id="snapName" placeholder="What's your name?" required />
              </div>
              <div class="form-group">
                <label for="snapCaption">Caption (Optional)</label>
                <textarea id="snapCaption" placeholder="Add a caption..." rows="3" style="resize: vertical;"></textarea>
              </div>
            </div>

            <!-- Auto-add confirmation (hidden until checked) -->
            <div id="auto-add-confirmation" style="display: none; padding: 12px; background: rgba(168, 85, 247, 0.15); border-radius: 6px; color: var(--text-primary); font-size: 0.9rem; line-height: 1.5;">
              üì∏ Your media will be posted with the current date and time. Ready to upload!
            </div>

            <div style="display: flex; gap: 8px;">
              <button type="submit" class="btn primary" style="flex: 1;">Post to Korner</button>
              <button type="button" class="btn secondary" onclick="closeSnapToBoardModal()" style="flex: 1;">Cancel</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- Video Message Recording Modal -->
  <div id="video-message-modal" class="category-modal">
    <div class="category-modal-content" style="max-width: 700px;">
      <div class="category-modal-header">
        <h2>Record Video </h2>
        <button class="category-modal-close" onclick="closeVideoMessageModal()" aria-label="Close modal">&times;</button>
      </div>
      <div class="category-modal-body">
        <div style="text-align: center;">
          <div style="position: relative; display: inline-block;">
            <video id="video-message-preview" width="640" height="480" autoplay muted style="border-radius: 8px; border: 2px solid var(--accent-gaming); background: #000;"></video>
            <canvas id="video-message-canvas" width="640" height="480" style="display: none;"></canvas>
            <div id="video-message-timer" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: #fff; padding: 8px 16px; border-radius: 6px; font-size: 1.2rem; font-weight: bold; display: none;">
              00:00 / 00:15
            </div>
          </div>
          <div style="margin-top: 20px; display: flex; gap: 12px; justify-content: center;">
            <button id="start-video-record" class="btn primary" style="padding: 12px 24px; font-size: 1rem;">
              üî¥ Start Recording (5-15s)
            </button>
            <button id="stop-video-record" class="btn secondary" style="padding: 12px 24px; font-size: 1rem; display: none;">
              ‚èπÔ∏è Stop Recording
            </button>
            <button id="use-video-message" class="btn primary" style="padding: 12px 24px; font-size: 1rem; display: none;">
              ‚úì Use This Video
            </button>
            <button id="retake-video-message" class="btn secondary" style="padding: 12px 24px; font-size: 1rem; display: none;">
              üîÑ Retake
            </button>
          </div>
          <p style="margin-top: 12px; color: var(--text-secondary); font-size: 0.9rem;">
            Record a short video to share with the Kommunity
          </p>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="footer-content">
      <p>¬© 2026 Kenechi Obiozor.</p>
      <nav class="mobile-tabs">
        <a href="projects.html" class="mobile-tab">Projects</a>
        <a href="resume.html" class="mobile-tab">Resume</a>
        <a href="contact.html" class="mobile-tab">Contact</a>
        <a href="archive.html" class="mobile-tab">Archive</a>
      </nav>
    </div>
  </footer>

  <!-- About Window -->
  <section class="window about-window" id="aboutWindow" style="position: fixed; top: 120px; left: 30px; display: block;">
    <div class="window-header drag-handle">
      <span class="dot red"></span>
      <span class="dot yellow"></span>
      <span class="dot green"></span>
      <span class="window-title">Me.txt</span>
    </div>
    <div class="window-body">
      <pre class="about-text">hi im Kenechi, but i did name this <span class="tooltip-word">kumachi<span class="tooltip-popup">"Bartholomew Kuma" (Kumachi) is a fictional character from "one piece" who is a priest focused on his community/church, who is known for his resilience, patience, empathy and determination.</span></span>.

<span class="tooltip-word">kumachi's korner<span class="tooltip-popup">  A korner for me and mine who may relate or wish to see. Like Kumachi, I preach to myself and all who listen.</span></span> is a digital congregation in which im working on blending all of my interests in its diverse forms. <br>
In order to create a page that shows my <span class="tooltip-word">Undertow<span class="tooltip-popup">A quiet internal current that shapes ones decisions or mood</span></span>.

</pre>
    </div>
  </section>

  <section class="window notes-window" id="notesWindow" style="position: fixed; bottom: 30px; right: 30px; top: auto; display: block;">
    <div class="window-header drag-handle">
      <span class="dot red"></span>
      <span class="dot yellow"></span>
      <span class="dot green"></span>
      <span class="window-title">Context.txt</span>
    </div>
    <div class="window-body">
      <pre class="about-text">Media, entertainment, art, music, films, writing whatever 
im <span class="tooltip-word">infatuated<span class="tooltip-popup">strong emotional pull<br>usually temporary<br>feels urgent or consuming</span></span> with / what's inspiring me at the moment.

Will be adding to it as much as i can, hoping to make this a digital library</pre>
    </div>
  </section>

  <!-- Kurrently Window -->
  <section class="window kurrently-window" id="kurrentlyWindow" style="position: fixed; top: 491px; left: 179.2px; transform: translateX(-50%); display: block; right: auto;">
    <div class="window-header drag-handle">
      <span class="dot red"></span>
      <span class="dot yellow"></span>
      <span class="dot green"></span>
      <span class="window-title">Kurrently</span>
    </div>
    <div class="window-body">
      <div id="kurrentlyContent" style="font-size: 0.85rem; line-height: 1.6; font-family: 'Courier New', monospace; min-height: 120px; white-space: pre-wrap;"></div>
    </div>
  </section>

  <script src="/js/search-index.js"></script>
  <script src="/js/site-search.js"></script>
  <script src="/js/security.js"></script>
  <script src="/js/weekly.js"></script>
  <script src="/js/globe.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tracking.js/1.1.3/tracking-min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tracking.js/1.1.3/data/eye-min.js"></script>
  <script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>
  <script>
    // The Interface - Webcam Mirror Effects with Eye Tracking
    document.addEventListener('DOMContentLoaded', () => {
      const video = document.getElementById('webcam');
      const canvas = document.getElementById('mirror-canvas');
      const ctx = canvas.getContext('2d');
      const buttons = document.querySelectorAll('.mode-buttons-vertical .ctrl-btn');
      const captureBtn = document.getElementById('capture-btn');
      const recordBtn = document.getElementById('record-btn');
      const recordTimer = document.getElementById('record-timer');
      const webcamToggleBtn = document.getElementById('webcam-toggle');
      const flipCameraBtn = document.getElementById('flip-camera-btn');
      
      let currentFacingMode = 'user'; // 'user' for front, 'environment' for back
      
      // Simple notification system
      function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 12px 20px;
          background: ${type === 'error' ? 'rgba(220, 38, 38, 0.95)' : 'rgba(139, 92, 246, 0.95)'};
          color: white;
          border-radius: 8px;
          font-size: 14px;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        `;
        document.body.appendChild(notification);
        setTimeout(() => {
          notification.style.opacity = '0';
          notification.style.transition = 'opacity 0.3s';
          setTimeout(() => notification.remove(), 300);
        }, 3000);
      }

      function getRandomKornerColors() {
        const palette = [
          '#F6E8FF', '#E8F1FF', '#E8FFF2', '#FFF2E8', '#FFF9E1',
          '#EDE9FE', '#DCFCE7', '#FFE4E6', '#E0F2FE', '#FAF5FF'
        ];
        const darkTextPalette = ['#0f172a', '#111827', '#1f2937', '#0b0f1a'];
        const lightTextPalette = ['#ffffff', '#f8fafc', '#f1f5f9', '#e2e8f0'];
        const bgColor = palette[Math.floor(Math.random() * palette.length)];
        const hex = bgColor.replace('#', '');
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        const textColor = luminance > 0.7
          ? darkTextPalette[Math.floor(Math.random() * darkTextPalette.length)]
          : lightTextPalette[Math.floor(Math.random() * lightTextPalette.length)];
        return { bgColor, textColor };
      }
      
      let currentMode = 'wireframe';
      let animationFrameId;
      let detectedEyes = [];
      
      // Temporal Grid Buffer
      const frameBuffer = [];
      const MAX_FRAMES = 180; // 6 seconds at 30fps

      let mediaRecorder = null;
      let recordedChunks = [];
      let isRecording = false;
      let recordStartTime = 0;
      let recordTimerInterval = null;
      
      let webcamStream = null;
      
      // Photobooth variables
      let photoboothActive = false;
      let photoboothFrames = [];
      let photoboothInterval = null;
      const PHOTOBOOTH_DELAY = 5000; // 5 seconds
      
      // --- EYE TRACKING INITIALIZATION ---
      const eyeTracker = new tracking.ObjectTracker('eye');
      eyeTracker.setInitialScale(2);
      eyeTracker.setStepSize(1);
      eyeTracker.setEdgesDensity(0.5);
      eyeTracker.on('track', function(event) {
        detectedEyes = event.data.length === 0 ? [] : event.data;
      });

      // Start Webcam Function
      function startWebcam() {
        navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: 640, 
            height: 480,
            facingMode: currentFacingMode
          } 
        })
          .then(stream => {
            webcamStream = stream;
            video.srcObject = stream;
            video.play();
            tracking.track('#webcam', eyeTracker);
            if (!animationFrameId) requestAnimationFrame(processFrame);
            webcamToggleBtn.textContent = 'STOP WEBCAM';
            flipCameraBtn.style.display = 'block'; // Show flip button when camera is on
          })
          .catch(err => console.error("Camera access denied.", err));
      }

      function stopWebcam() {
        if (webcamStream) {
          webcamStream.getTracks().forEach(track => track.stop());
          webcamStream = null;
        }
        video.pause();
        video.srcObject = null;
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Camera is off', canvas.width / 2, canvas.height / 2);
        webcamToggleBtn.textContent = 'START WEBCAM';
        flipCameraBtn.style.display = 'none'; // Hide flip button when camera is off
      }

      webcamToggleBtn.addEventListener('click', () => {
        if (webcamStream) {
          stopWebcam();
        } else {
          startWebcam();
        }
      });

      // Flip Camera Button Listener
      flipCameraBtn.addEventListener('click', () => {
        if (webcamStream) {
          // Toggle between front and back camera
          currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
          
          // Stop current stream and restart with new facing mode
          webcamStream.getTracks().forEach(track => track.stop());
          webcamStream = null;
          
          // Restart webcam with new facing mode
          navigator.mediaDevices.getUserMedia({ 
            video: { 
              width: 640, 
              height: 480,
              facingMode: currentFacingMode
            } 
          })
            .then(stream => {
              webcamStream = stream;
              video.srcObject = stream;
              video.play();
              tracking.track('#webcam', eyeTracker);
              if (!animationFrameId) requestAnimationFrame(processFrame);
            })
            .catch(err => console.error("Camera flip failed.", err));
        }
      });

      // --- UI EVENT LISTENERS ---
      buttons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          buttons.forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          currentMode = e.target.dataset.mode;
          
          canvas.style.transform = "scaleX(-1)";

          // Clear temporal buffer if we switch modes to save RAM
          if (currentMode !== 'temporal') frameBuffer.length = 0;
          
          ctx.globalAlpha = 1.0;
          ctx.globalCompositeOperation = 'source-over';
        });
      });


      // Camera Shutter Capture
      captureBtn.addEventListener('click', () => {
        // Create temporary canvas for timestamp overlay
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Draw the filtered canvas
        tempCtx.drawImage(canvas, 0, 0);
        
        // Add timestamp overlay
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        // Bottom right corner with background
        tempCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        tempCtx.fillRect(tempCanvas.width - 200, tempCanvas.height - 50, 190, 45);
        
        tempCtx.fillStyle = '#fff';
        tempCtx.font = 'bold 14px Arial';
        tempCtx.textAlign = 'right';
        tempCtx.fillText(dateStr, tempCanvas.width - 15, tempCanvas.height - 28);
        tempCtx.fillText(timeStr, tempCanvas.width - 15, tempCanvas.height - 10);

        const link = document.createElement('a');
        link.download = `archive_${currentMode}_${Date.now()}.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
        
        // Flash effect
        ctx.fillStyle = "white";
        ctx.fillRect(0,0,canvas.width,canvas.height);
      });

      // Record Clip (canvas capture)
      recordBtn.addEventListener('click', () => {
        if (!isRecording) {
          recordedChunks = [];
          recordStartTime = Date.now();
          recordTimer.textContent = '00:00';
          recordTimer.classList.remove('hidden');
          recordTimerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
            const mins = String(Math.floor(elapsed / 60)).padStart(2, '0');
            const secs = String(elapsed % 60).padStart(2, '0');
            recordTimer.textContent = `${mins}:${secs}`;
          }, 500);
          // Capture canvas video + audio from webcam
          const canvasStream = canvas.captureStream(30);
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const audioDestination = audioContext.createMediaStreamDestination();
          
          // If webcam is active, mix its audio with the recording
          if (webcamStream) {
            const audioTracks = webcamStream.getAudioTracks();
            if (audioTracks.length > 0) {
              const audioSource = audioContext.createMediaStreamSource(webcamStream);
              audioSource.connect(audioDestination);
            }
          }
          
          // Combine canvas video with audio stream
          const stream = new MediaStream();
          canvasStream.getVideoTracks().forEach(track => stream.addTrack(track));
          audioDestination.stream.getAudioTracks().forEach(track => stream.addTrack(track));
          let mimeType = 'video/webm;codecs=vp9';
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'video/webm;codecs=vp8';
          }
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'video/webm';
          }

          mediaRecorder = new MediaRecorder(stream, { mimeType });
          mediaRecorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };
          mediaRecorder.onstop = () => {
            if (recordTimerInterval) {
              clearInterval(recordTimerInterval);
              recordTimerInterval = null;
            }
            const blob = new Blob(recordedChunks, { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `interface_recording_${currentMode}_${Date.now()}.webm`;
            link.click();
            URL.revokeObjectURL(url);
          };

          mediaRecorder.start();
          isRecording = true;
          recordBtn.classList.add('recording');
          recordBtn.textContent = 'STOP';
        } else {
          mediaRecorder.stop();
          isRecording = false;
          recordBtn.classList.remove('recording');
          recordBtn.textContent = 'REC';
          recordTimer.classList.add('hidden');
          if (recordTimerInterval) {
            clearInterval(recordTimerInterval);
            recordTimerInterval = null;
          }
        }
      });

      // Photobooth functionality
      const photoboothBtn = document.getElementById('photobooth-btn');
      const photoboothPanel = document.getElementById('photobooth-panel');
      const photoboothGrid = document.getElementById('photobooth-grid');
      const downloadPhotoboothBtn = document.getElementById('download-photobooth');
      const clearPhotoboothBtn = document.getElementById('clear-photobooth');

      if (photoboothBtn) {
        console.log('Photobooth button found and listener attached');
        photoboothBtn.addEventListener('click', () => {
          console.log('Photobooth button clicked!');
          if (!webcamStream) {
            showNotification('Please start your camera first!', 'error');
            return;
          }

          photoboothActive = !photoboothActive;
          photoboothBtn.classList.toggle('active', photoboothActive);
          photoboothPanel.classList.toggle('hidden', !photoboothActive);

          if (photoboothActive) {
            // Start auto-capturing frames
            capturePhotoboothFrame();
            photoboothInterval = setInterval(capturePhotoboothFrame, PHOTOBOOTH_DELAY);
            showNotification('Photobooth started - capturing every 5 seconds');
          } else {
            // Stop auto-capturing
            if (photoboothInterval) {
              clearInterval(photoboothInterval);
              photoboothInterval = null;
            }
            showNotification('Photobooth stopped');
          }
        });
      }

      function capturePhotoboothFrame() {
        // Create temporary canvas for timestamp overlay
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Draw the filtered canvas
        tempCtx.drawImage(canvas, 0, 0);
        
        // Add timestamp overlay
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        // Bottom right corner with background
        tempCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        tempCtx.fillRect(tempCanvas.width - 200, tempCanvas.height - 50, 190, 45);
        
        tempCtx.fillStyle = '#fff';
        tempCtx.font = 'bold 14px Arial';
        tempCtx.textAlign = 'right';
        tempCtx.fillText(dateStr, tempCanvas.width - 15, tempCanvas.height - 28);
        tempCtx.fillText(timeStr, tempCanvas.width - 15, tempCanvas.height - 10);
        
        const frameData = tempCanvas.toDataURL('image/png');
        const timestamp = timeStr;
        photoboothFrames.push({ data: frameData, time: timestamp });

        const frameDiv = document.createElement('div');
        frameDiv.className = 'photobooth-frame';
        frameDiv.innerHTML = `
          <img src="${frameData}" alt="Frame ${photoboothFrames.length}" />
          <div class="photobooth-timestamp">${timestamp}</div>
        `;
        photoboothGrid.appendChild(frameDiv);
      }

      if (downloadPhotoboothBtn) {
        downloadPhotoboothBtn.addEventListener('click', () => {
          if (photoboothFrames.length === 0) {
            showNotification('No frames captured yet', 'error');
            return;
          }

          // Create a single canvas with all frames in a grid
          const gridCanvas = document.createElement('canvas');
          const gridCtx = gridCanvas.getContext('2d');
          const cols = 3;
          const rows = Math.ceil(photoboothFrames.length / cols);
          const frameWidth = 320;
          const frameHeight = 240;
          
          gridCanvas.width = cols * frameWidth;
          gridCanvas.height = rows * frameHeight;
          gridCtx.fillStyle = '#000';
          gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

          photoboothFrames.forEach((frame, idx) => {
            const img = new Image();
            img.onload = () => {
              const col = idx % cols;
              const row = Math.floor(idx / cols);
              gridCtx.drawImage(img, col * frameWidth, row * frameHeight, frameWidth, frameHeight);
              
              // Add timestamp
              gridCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
              gridCtx.fillRect(col * frameWidth, row * frameHeight + frameHeight - 20, frameWidth, 20);
              gridCtx.fillStyle = '#fff';
              gridCtx.font = '12px Arial';
              gridCtx.textAlign = 'center';
              gridCtx.fillText(frame.time, col * frameWidth + frameWidth / 2, row * frameHeight + frameHeight - 6);

              // Download after last frame
              if (idx === photoboothFrames.length - 1) {
                const link = document.createElement('a');
                link.download = `photobooth_${Date.now()}.png`;
                link.href = gridCanvas.toDataURL();
                link.click();
                showNotification('Photobooth downloaded!');
              }
            };
            img.src = frame.data;
          });
        });
      }

      if (clearPhotoboothBtn) {
        clearPhotoboothBtn.addEventListener('click', () => {
          photoboothFrames = [];
          photoboothGrid.innerHTML = '';
          showNotification('Photobooth cleared');
        });
      }

      // Snap to Board functionality
      const snapToBoardBtn = document.getElementById('snap-to-board-btn');
      if (snapToBoardBtn) {
        snapToBoardBtn.addEventListener('click', () => {
          if (!webcamStream) {
            showNotification('Please start your camera first!', 'error');
            return;
          }

          // Create temporary canvas for timestamp overlay
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = canvas.width;
          tempCanvas.height = canvas.height;
          const tempCtx = tempCanvas.getContext('2d');
          
          // Draw the filtered canvas
          tempCtx.drawImage(canvas, 0, 0);
          
          // Add timestamp overlay
          const now = new Date();
          const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
          
          // Bottom right corner with background
          tempCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          tempCtx.fillRect(tempCanvas.width - 200, tempCanvas.height - 50, 190, 45);
          
          tempCtx.fillStyle = '#fff';
          tempCtx.font = 'bold 14px Arial';
          tempCtx.textAlign = 'right';
          tempCtx.fillText(dateStr, tempCanvas.width - 15, tempCanvas.height - 28);
          tempCtx.fillText(timeStr, tempCanvas.width - 15, tempCanvas.height - 10);
          
          // Capture frame with timestamp
          const imageData = tempCanvas.toDataURL('image/png');
          
          // Store for the modal
          window.snapPhotoData = imageData;
          
          // Show modal with preview
          const modal = document.getElementById('snap-to-board-modal');
          const previewImg = document.getElementById('snap-preview-img');
          previewImg.src = imageData;
          modal.style.display = 'flex';
          
          // Focus on name input
          setTimeout(() => document.getElementById('snapName').focus(), 100);
        });
      }

      // Handle snap post form submission
      const snapPostForm = document.getElementById('snap-post-form');
      if (snapPostForm) {
        // Handle auto-add checkbox toggle
        const autoAddCheckbox = document.getElementById('autoAddCheckbox');
        const manualFormSection = document.getElementById('manual-form-section');
        const autoAddConfirmation = document.getElementById('auto-add-confirmation');
        const snapName = document.getElementById('snapName');

        if (autoAddCheckbox) {
          autoAddCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
              // Auto-add mode: hide form, show confirmation
              manualFormSection.style.display = 'none';
              autoAddConfirmation.style.display = 'block';
              snapName.removeAttribute('required');
            } else {
              // Manual mode: show form, hide confirmation
              manualFormSection.style.display = 'block';
              autoAddConfirmation.style.display = 'none';
              snapName.setAttribute('required', '');
            }
          });
        }

        snapPostForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          
          const isAutoAdd = autoAddCheckbox.checked;
          const name = document.getElementById('snapName').value.trim();
          const caption = document.getElementById('snapCaption').value.trim();
          const { bgColor, textColor } = getRandomKornerColors();
          
          // Validation: name required only for manual mode
          if (!isAutoAdd && !name) {
            showNotification('Please enter your name!', 'error');
            return;
          }
          
          // Disable submit button
          const submitBtn = snapPostForm.querySelector('button[type="submit"]');
          submitBtn.disabled = true;
          
          try {
            // Check if we have photo or video data
            const isVideo = window.snapVideoData && window.snapVideoData !== null;
            
            // Create entry based on mode and media type
            const entry = isAutoAdd 
              ? {
                  name: 'Anonymous',
                  text: isVideo ? `Video message üé•` : `Snapped with The Kamera üì∑`,
                  photo: isVideo ? null : window.snapPhotoData,
                  video: isVideo ? window.snapVideoData : null,
                  timestamp: new Date().toISOString(),
                  textColor,
                  bgColor
                }
              : {
                  name: name,
                  text: caption || (isVideo ? 'Video message üé•' : 'Snapped with The Kamera üì∑'),
                  photo: isVideo ? null : window.snapPhotoData,
                  video: isVideo ? window.snapVideoData : null,
                  timestamp: new Date().toISOString(),
                  textColor,
                  bgColor
                };
            
            const success = await addEntry(entry);
            
            if (success) {
              closeSnapToBoardModal();
              showNotification(isAutoAdd 
                ? `üéâ Your ${isVideo ? 'video' : 'photo'} has been auto-posted to Kommunity Korner!` 
                : `üéâ Your ${isVideo ? 'video' : 'photo'} has been posted to Kommunity Korner!`);
              snapPostForm.reset();
              autoAddCheckbox.checked = false;
              manualFormSection.style.display = 'block';
              autoAddConfirmation.style.display = 'none';
              snapName.setAttribute('required', '');
            } else {
              showNotification('Failed to post. Please try again.', 'error');
            }
          } catch (error) {
            console.error('Error posting to board:', error);
            showNotification('Error posting to board.', 'error');
          } finally {
            submitBtn.disabled = false;
          }
        });
      }

      // Close snap-to-board modal
      window.closeSnapToBoardModal = function() {
        const modal = document.getElementById('snap-to-board-modal');
        modal.style.display = 'none';
        window.snapPhotoData = null;
        window.snapVideoData = null;
        
        // Hide video preview, show image preview
        const previewImg = document.getElementById('snap-preview-img');
        const previewVideo = document.getElementById('snap-preview-video');
        if (previewImg) previewImg.style.display = 'block';
        if (previewVideo) {
          previewVideo.style.display = 'none';
          previewVideo.src = '';
        }
        
        // Reset form state
        const autoAddCheckbox = document.getElementById('autoAddCheckbox');
        const manualFormSection = document.getElementById('manual-form-section');
        const autoAddConfirmation = document.getElementById('auto-add-confirmation');
        if (autoAddCheckbox) {
          autoAddCheckbox.checked = false;
          manualFormSection.style.display = 'block';
          autoAddConfirmation.style.display = 'none';
        }
      };

      // Video Message Recording Functionality
      const videoMessageBtn = document.getElementById('video-message-btn');
      let videoMessageRecorder = null;
      let videoMessageChunks = [];
      let videoMessageStream = null;
      let videoMessageRecordStartTime = 0;
      let videoMessageTimerInterval = null;
      let videoTimestampInterval = null;
      const MAX_VIDEO_DURATION = 15000; // 15 seconds
      const MIN_VIDEO_DURATION = 5000; // 5 seconds
      
      // Function to draw timestamp on canvas during video recording
      function drawVideoTimestamp() {
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        // Save current context
        ctx.save();
        
        // Bottom right corner with background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(canvas.width - 200, canvas.height - 50, 190, 45);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(dateStr, canvas.width - 15, canvas.height - 28);
        ctx.fillText(timeStr, canvas.width - 15, canvas.height - 10);
        
        // Restore context
        ctx.restore();
      }

      if (videoMessageBtn) {
        videoMessageBtn.addEventListener('click', () => {
          if (!webcamStream) {
            showNotification('Please start your camera first!', 'error');
            return;
          }
          
          // Open video message modal
          const modal = document.getElementById('video-message-modal');
          const videoPreview = document.getElementById('video-message-preview');
          const videoCanvas = document.getElementById('video-message-canvas');
          
          modal.style.display = 'flex';
          
          // Set up video preview with current webcam mode
          videoMessageStream = canvas.captureStream(30);
          
          // Add audio from webcam
          if (webcamStream) {
            const audioTracks = webcamStream.getAudioTracks();
            audioTracks.forEach(track => videoMessageStream.addTrack(track));
          }
          
          videoPreview.srcObject = videoMessageStream;
          videoPreview.muted = true;
          videoPreview.play();
        });
      }

      // Start video recording
      const startVideoRecordBtn = document.getElementById('start-video-record');
      if (startVideoRecordBtn) {
        startVideoRecordBtn.addEventListener('click', () => {
          const videoTimer = document.getElementById('video-message-timer');
          const stopBtn = document.getElementById('stop-video-record');
          
          videoMessageChunks = [];
          videoMessageRecordStartTime = Date.now();
          
          // Show timer
          videoTimer.style.display = 'block';
          videoTimer.textContent = '00:00 / 00:15';
          
          // Set up MediaRecorder
          let mimeType = 'video/webm;codecs=vp9';
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'video/webm;codecs=vp8';
          }
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'video/webm';
          }
          
          videoMessageRecorder = new MediaRecorder(videoMessageStream, { mimeType });
          
          videoMessageRecorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
              videoMessageChunks.push(event.data);
            }
          };
          
          videoMessageRecorder.onstop = () => {
            // Check if minimum duration met
            const duration = Date.now() - videoMessageRecordStartTime;
            
            if (duration < MIN_VIDEO_DURATION) {
              showNotification('Video must be at least 5 seconds long', 'error');
              resetVideoRecording();
              return;
            }
            
            // Create blob and preview
            const blob = new Blob(videoMessageChunks, { type: mimeType });
            const videoUrl = URL.createObjectURL(blob);
            
            // Convert to base64 for storage
            const reader = new FileReader();
            reader.onloadend = function() {
              window.recordedVideoMessage = reader.result;
              
              // Show preview and use/retake buttons
              const videoPreview = document.getElementById('video-message-preview');
              videoPreview.srcObject = null;
              videoPreview.src = videoUrl;
              videoPreview.muted = false;
              videoPreview.controls = true;
              
              startVideoRecordBtn.style.display = 'none';
              stopBtn.style.display = 'none';
              document.getElementById('use-video-message').style.display = 'inline-block';
              document.getElementById('retake-video-message').style.display = 'inline-block';
              videoTimer.style.display = 'none';
            };
            reader.readAsDataURL(blob);
          };
          
          videoMessageRecorder.start();
          
          // Start drawing timestamp on canvas during recording
          videoTimestampInterval = setInterval(() => {
            drawVideoTimestamp();
          }, 1000); // Update timestamp every second
          
          // Update UI
          startVideoRecordBtn.style.display = 'none';
          stopBtn.style.display = 'inline-block';
          
          // Update timer
          videoMessageTimerInterval = setInterval(() => {
            const elapsed = Math.min(MAX_VIDEO_DURATION, Date.now() - videoMessageRecordStartTime);
            const secs = Math.floor(elapsed / 1000);
            const maxSecs = Math.floor(MAX_VIDEO_DURATION / 1000);
            videoTimer.textContent = `00:${String(secs).padStart(2, '0')} / 00:${String(maxSecs).padStart(2, '0')}`;
            
            // Auto-stop at max duration
            if (elapsed >= MAX_VIDEO_DURATION) {
              stopBtn.click();
            }
          }, 100);
        });
      }

      // Stop video recording
      const stopVideoRecordBtn = document.getElementById('stop-video-record');
      if (stopVideoRecordBtn) {
        stopVideoRecordBtn.addEventListener('click', () => {
          if (videoMessageRecorder && videoMessageRecorder.state === 'recording') {
            videoMessageRecorder.stop();
            
            // Stop timestamp overlay
            if (videoTimestampInterval) {
              clearInterval(videoTimestampInterval);
              videoTimestampInterval = null;
            }
            
            if (videoMessageTimerInterval) {
              clearInterval(videoMessageTimerInterval);
              videoMessageTimerInterval = null;
            }
          }
        });
      }

      // Use video message
      const useVideoMessageBtn = document.getElementById('use-video-message');
      if (useVideoMessageBtn) {
        useVideoMessageBtn.addEventListener('click', () => {
          if (!window.recordedVideoMessage) {
            showNotification('No video recorded', 'error');
            return;
          }
          
          // Store video data
          window.snapVideoData = window.recordedVideoMessage;
          window.snapPhotoData = null;
          
          // Close video modal
          closeVideoMessageModal();
          
          // Open snap to board modal with video preview
          const modal = document.getElementById('snap-to-board-modal');
          const previewImg = document.getElementById('snap-preview-img');
          const previewVideo = document.getElementById('snap-preview-video');
          
          previewImg.style.display = 'none';
          previewVideo.style.display = 'block';
          previewVideo.src = window.recordedVideoMessage;
          
          modal.style.display = 'flex';
          
          // Focus on name input
          setTimeout(() => document.getElementById('snapName').focus(), 100);
        });
      }

      // Retake video message
      const retakeVideoMessageBtn = document.getElementById('retake-video-message');
      if (retakeVideoMessageBtn) {
        retakeVideoMessageBtn.addEventListener('click', () => {
          resetVideoRecording();
        });
      }

      function resetVideoRecording() {
        const videoPreview = document.getElementById('video-message-preview');
        const startBtn = document.getElementById('start-video-record');
        const stopBtn = document.getElementById('stop-video-record');
        const useBtn = document.getElementById('use-video-message');
        const retakeBtn = document.getElementById('retake-video-message');
        const videoTimer = document.getElementById('video-message-timer');
        
        // Reset video preview
        videoPreview.src = '';
        videoPreview.srcObject = videoMessageStream;
        videoPreview.muted = true;
        videoPreview.controls = false;
        videoPreview.play();
        
        // Reset UI
        startBtn.style.display = 'inline-block';
        stopBtn.style.display = 'none';
        useBtn.style.display = 'none';
        retakeBtn.style.display = 'none';
        videoTimer.style.display = 'none';
        
        // Clear recorded data
        window.recordedVideoMessage = null;
        videoMessageChunks = [];
      }

      // Close video message modal
      window.closeVideoMessageModal = function() {
        const modal = document.getElementById('video-message-modal');
        const videoPreview = document.getElementById('video-message-preview');
        
        modal.style.display = 'none';
        
        // Stop video preview
        if (videoPreview.srcObject) {
          videoPreview.srcObject = null;
        }
        videoPreview.src = '';
        
        // Stop any ongoing recording
        if (videoMessageRecorder && videoMessageRecorder.state === 'recording') {
          videoMessageRecorder.stop();
        }
        
        // Stop timestamp overlay
        if (videoTimestampInterval) {
          clearInterval(videoTimestampInterval);
          videoTimestampInterval = null;
        }
        
        if (videoMessageTimerInterval) {
          clearInterval(videoMessageTimerInterval);
          videoMessageTimerInterval = null;
        }
        
        // Reset UI
        resetVideoRecording();
      };

      // Extract dominant colors from canvas
      function extractDominantColors() {
        try {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          // Sample every Nth pixel for performance
          const step = 4;
          const colors = [];
          
          for (let i = 0; i < data.length; i += step * 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            
            // Skip transparent or near-black pixels
            if (a > 128 && (r + g + b) > 30) {
              colors.push({ r, g, b });
            }
          }
          
          // Use k-means clustering to find 5 dominant colors
          const dominantColors = getKMeansClusters(colors, 5);
          updateColorDisplay(dominantColors);
        } catch (e) {
          // Silently fail if canvas is not ready
        }
      }

      // K-means clustering algorithm
      function getKMeansClusters(colors, k) {
        if (colors.length === 0) return [];
        
        // Initialize centroids randomly
        let centroids = [];
        for (let i = 0; i < Math.min(k, colors.length); i++) {
          const idx = Math.floor(Math.random() * colors.length);
          centroids.push(colors[idx]);
        }
        
        // K-means iterations
        for (let iter = 0; iter < 5; iter++) {
          // Assign colors to nearest centroid
          const clusters = Array(k).fill(null).map(() => []);
          
          colors.forEach(color => {
            let minDist = Infinity;
            let closestCluster = 0;
            
            centroids.forEach((centroid, idx) => {
              const dist = Math.sqrt(
                Math.pow(color.r - centroid.r, 2) +
                Math.pow(color.g - centroid.g, 2) +
                Math.pow(color.b - centroid.b, 2)
              );
              
              if (dist < minDist) {
                minDist = dist;
                closestCluster = idx;
              }
            });
            
            clusters[closestCluster].push(color);
          });
          
          // Update centroids
          centroids = clusters.map((cluster, idx) => {
            if (cluster.length === 0) return centroids[idx];
            
            const avgR = Math.round(cluster.reduce((sum, c) => sum + c.r, 0) / cluster.length);
            const avgG = Math.round(cluster.reduce((sum, c) => sum + c.g, 0) / cluster.length);
            const avgB = Math.round(cluster.reduce((sum, c) => sum + c.b, 0) / cluster.length);
            
            return { r: avgR, g: avgG, b: avgB };
          });
        }
        
        // Convert back to RGB and sort by brightness/saturation
        return centroids
          .map(c => ({
            r: Math.max(0, Math.min(255, c.r)),
            g: Math.max(0, Math.min(255, c.g)),
            b: Math.max(0, Math.min(255, c.b))
          }))
          .filter(c => (c.r + c.g + c.b) > 20) // Remove near-black
          .sort((a, b) => {
            // Sort by luminance
            const lumA = 0.299 * a.r + 0.587 * a.g + 0.114 * a.b;
            const lumB = 0.299 * b.r + 0.587 * b.g + 0.114 * b.b;
            return lumB - lumA;
          })
          .slice(0, 5);
      }

      // Update color display with hex swatches
      function updateColorDisplay(colors) {
        const swatches = document.getElementById('colorSwatches');
        
        if (!swatches) return;
        
        // Ensure we have exactly 5 colors
        while (colors.length < 5) {
          colors.push({ r: 100, g: 100, b: 100 });
        }
        
        const swatchElements = swatches.querySelectorAll('.color-swatch');
        
        colors.slice(0, 5).forEach((color, idx) => {
          const hex = rgbToHex(color.r, color.g, color.b);
          const rgbString = `rgb(${color.r}, ${color.g}, ${color.b})`;
          
          // Update swatch
          if (swatchElements[idx]) {
            swatchElements[idx].style.background = rgbString;
            swatchElements[idx].title = hex;
            swatchElements[idx].setAttribute('data-hex', hex);
          }
        });
      }

      // Convert RGB to Hex
      function rgbToHex(r, g, b) {
        return "#" + [r, g, b].map(x => {
          const hex = x.toString(16);
          return hex.length === 1 ? "0" + hex : hex;
        }).join('').toUpperCase();
      }

      // Main Processing Loop
      function processFrame() {
        if (video.paused || video.ended) {
            animationFrameId = requestAnimationFrame(processFrame);
            return;
        }

        switch (currentMode) {
          case 'wireframe': drawWireframe(); break;
          case 'thermal': drawThermal(); break;
          case 'zeroday': drawZeroDay(); break;
          case 'temporal': drawTemporalGrid(); break;
          case 'watercolor': drawWatercolor(); break;
          case 'constellation': drawConstellation(); break;
        }
        
        // Extract and display dominant colors in real-time
        extractDominantColors();
        
        animationFrameId = requestAnimationFrame(processFrame);
      }

      // --- NEW 1. TEMPORAL GRID (CCTV Delays) ---
      function drawTemporalGrid() {
        const w = canvas.width / 2;
        const h = canvas.height / 2;
        
        // Save current frame to an offscreen canvas for memory efficiency
        const offCanvas = document.createElement('canvas');
        offCanvas.width = w; offCanvas.height = h;
        const offCtx = offCanvas.getContext('2d');
        offCtx.drawImage(video, 0, 0, w, h);
        
        // Add to buffer, remove oldest if over limit
        frameBuffer.push(offCanvas);
        if (frameBuffer.length > MAX_FRAMES) frameBuffer.shift();

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Frame Indexes (approx 30fps)
        const live = frameBuffer.length - 1;
        const delay2s = Math.max(0, frameBuffer.length - 60);
        const delay4s = Math.max(0, frameBuffer.length - 120);
        const delay6s = Math.max(0, frameBuffer.length - 180);

        // Draw Live Feed (Top Left)
        if (frameBuffer[live]) ctx.drawImage(frameBuffer[live], 0, 0, w, h);
        
        // Draw 2s Delay (Top Right)
        if (frameBuffer[delay2s]) {
          ctx.drawImage(frameBuffer[delay2s], w, 0, w, h);
          drawCCTVText(w + 10, 20, "CAM 02 - T-2.0s");
        }
        
        // Draw 4s Delay (Bottom Left)
        if (frameBuffer[delay4s]) {
          ctx.drawImage(frameBuffer[delay4s], 0, h, w, h);
          drawCCTVText(10, h + 20, "CAM 03 - T-4.0s");
        }
        
        // Draw 6s Delay (Bottom Right)
        if (frameBuffer[delay6s]) {
          ctx.drawImage(frameBuffer[delay6s], w, h, w, h);
          drawCCTVText(w + 10, h + 20, "CAM 04 - T-6.0s");
        }

        drawCCTVText(10, 20, "CAM 01 - LIVE");
        
        // Draw Crosshairs/Grid lines
        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w, 0); ctx.lineTo(w, canvas.height); // Vertical
        ctx.moveTo(0, h); ctx.lineTo(canvas.width, h); // Horizontal
        ctx.stroke();
      }

      function drawCCTVText(x, y, text) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
        ctx.font = "12px Courier New";
        ctx.fillText(text, x, y);
      }

      // --- NEON WIREFRAME ---
      function drawWireframe() {
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'difference';
        ctx.drawImage(video, -2, -2, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
          if ((data[i] + data[i+1] + data[i+2]) / 3 > 20) {
            data[i] = 0; data[i+1] = 255; data[i+2] = 136; 
          } else {
            data[i] = data[i+1] = data[i+2] = 0;
          }
        }
        ctx.putImageData(imgData, 0, 0);
      }

      // --- TRUE FLIR THERMAL VISION ---
      function drawThermal() {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
          let lum = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
          if (lum < 40) { data[i] = 0; data[i+1] = 0; data[i+2] = lum * 6.3; } 
          else if (lum < 100) { let t = (lum - 40) / 60; data[i] = t * 255; data[i+1] = 0; data[i+2] = 255 - (t * 255); } 
          else if (lum < 180) { let t = (lum - 100) / 80; data[i] = 255; data[i+1] = t * 255; data[i+2] = 0; } 
          else { let t = (lum - 180) / 75; data[i] = 255; data[i+1] = 255; data[i+2] = t * 255; }
        }
        ctx.putImageData(imgData, 0, 0);
      }

      // --- ZERO-DAY ANONYMIZER ---
      function drawZeroDay() {
        // 1. Clear the canvas/Draw the fresh video frame first
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // 2. Check if detectedEyes exists and has data
        if (detectedEyes && detectedEyes.length > 0) {
          detectedEyes.forEach(rect => {
            // Calculate responsive expansion (clamped to canvas boundaries)
            let x = Math.max(0, rect.x - 50);
            let y = Math.max(0, rect.y - 40);
            let w = Math.min(canvas.width - x, rect.width + 100);
            let h = Math.min(canvas.height - y, rect.height + 80);
            
            // Triple-layer pixelation
            pixelateRegion(x, y, w, h, 12);
            pixelateRegion(x + 8, y + 8, Math.max(1, w - 16), Math.max(1, h - 16), 8);
            pixelateRegion(x + 15, y + 12, Math.max(1, w - 30), Math.max(1, h - 24), 4);
            
            // Static Glitch Bars
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(x - 15, rect.y + (rect.height / 2) - 12, w + 30, 24);
            
            // Matrix/Glitch Characters
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 16px Courier';
            const glitchChars = ['‚ñà', '‚ñì', '‚ñí', '‚ñë', '‚ñ∞', 'X', '#', 'üîí', '‚ñ†'];
            for (let i = 0; i < 10; i++) {
              const char = glitchChars[Math.floor(Math.random() * glitchChars.length)];
              ctx.fillText(char, x + Math.random() * w, y + Math.random() * h);
            }
            
            // Moving Scan Lines (Time-based for smooth movement)
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.lineWidth = 2;
            const time = Date.now() * 0.05; 
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              let scanY = y + ((time + (i * 20)) % h);
              ctx.moveTo(x, scanY);
              ctx.lineTo(x + w, scanY);
              ctx.stroke();
            }
          });
        }
      }

      function pixelateRegion(x, y, w, h, size) {
        x = Math.max(0, x); y = Math.max(0, y);
        w = Math.min(canvas.width - x, w); h = Math.min(canvas.height - y, h);
        if(w <= 0 || h <= 0) return;
        const imgData = ctx.getImageData(x, y, w, h);
        const data = imgData.data;
        for(let py = 0; py < h; py += size) {
          for(let px = 0; px < w; px += size) {
            let i = (py * w + px) * 4;
            ctx.fillStyle = `rgb(${data[i]},${data[i+1]},${data[i+2]})`;
            ctx.fillRect(x + px, y + py, size, size);
          }
        }
      }

      // --- WATERCOLOR / INK WASH MODE ---
      let watercolorBlobs = [];
      
      function drawWatercolor() {
        // Draw video frame
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Sample dominant colors from current frame
        const dominantColors = extractDominantColorsForWatercolor();
        
        // Update or create blobs every few frames for smooth animation
        if (Math.random() < 0.1 || watercolorBlobs.length === 0) {
          watercolorBlobs = [];
          
          // Create 8-12 large blurred blobs in dominant colors
          const blobCount = 8 + Math.floor(Math.random() * 5);
          for (let i = 0; i < blobCount; i++) {
            const color = dominantColors[Math.floor(Math.random() * dominantColors.length)];
            watercolorBlobs.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              radius: 60 + Math.random() * 120,
              color: color,
              alpha: 0.3 + Math.random() * 0.4,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2
            });
          }
        }
        
        // Clear canvas with soft white background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw blurred blobs
        watercolorBlobs.forEach(blob => {
          // Animate blob positions slightly
          blob.x += blob.vx;
          blob.y += blob.vy;
          
          // Bounce off edges
          if (blob.x < 0 || blob.x > canvas.width) blob.vx *= -1;
          if (blob.y < 0 || blob.y > canvas.height) blob.vy *= -1;
          
          // Create gradient for soft watercolor effect
          const gradient = ctx.createRadialGradient(
            blob.x, blob.y, 0,
            blob.x, blob.y, blob.radius
          );
          
          gradient.addColorStop(0, `rgba(${blob.color.r}, ${blob.color.g}, ${blob.color.b}, ${blob.alpha})`);
          gradient.addColorStop(0.5, `rgba(${blob.color.r}, ${blob.color.g}, ${blob.color.b}, ${blob.alpha * 0.5})`);
          gradient.addColorStop(1, `rgba(${blob.color.r}, ${blob.color.g}, ${blob.color.b}, 0)`);
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(blob.x, blob.y, blob.radius, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Apply subtle blur effect
        ctx.globalAlpha = 0.95;
        ctx.filter = 'blur(8px)';
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';
        ctx.globalAlpha = 1.0;
      }
      
      function extractDominantColorsForWatercolor() {
        try {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          const step = 10;
          const colors = [];
          
          for (let i = 0; i < data.length; i += step * 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            
            if (a > 128 && (r + g + b) > 50) {
              colors.push({ r, g, b });
            }
          }
          
          if (colors.length === 0) return [{ r: 200, g: 100, b: 150 }];
          
          return getKMeansClusters(colors, 5);
        } catch (e) {
          return [{ r: 200, g: 100, b: 150 }];
        }
      }

      // --- CONSTELLATION / STAR CHART MODE ---
      let constellationPoints = [];
      
      function drawConstellation() {
        // Draw video and apply edge detection
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Get edge-detected bright points
        const brightPoints = detectBrightEdges();
        
        // Update constellation points (smooth transition)
        constellationPoints = brightPoints;
        
        // Dark starfield background
        ctx.fillStyle = 'rgba(5, 10, 25, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw stars (bright points)
        ctx.fillStyle = '#ffffff';
        constellationPoints.forEach(point => {
          // Draw star with glow
          const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, 3);
          gradient.addColorStop(0, `rgba(255, 255, 255, ${point.brightness})`);
          gradient.addColorStop(0.5, `rgba(200, 220, 255, ${point.brightness * 0.5})`);
          gradient.addColorStop(1, 'rgba(150, 180, 255, 0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Connect nearby points with lines (constellation effect)
        ctx.strokeStyle = 'rgba(150, 180, 255, 0.4)';
        ctx.lineWidth = 1.5;
        
        for (let i = 0; i < constellationPoints.length; i++) {
          const p1 = constellationPoints[i];
          
          // Find nearby points
          for (let j = i + 1; j < constellationPoints.length; j++) {
            const p2 = constellationPoints[j];
            const distance = Math.sqrt(
              Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
            );
            
            // Connect if within threshold distance (increased from 80 to 150)
            if (distance < 150) {
              const alpha = (1 - distance / 150) * 0.6;
              ctx.strokeStyle = `rgba(150, 180, 255, ${alpha})`;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
          }
        }
      }
      
      function detectBrightEdges() {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        tempCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        const points = [];
        const step = 8;
        
        // Sobel edge detection with brightness sampling
        for (let y = step; y < canvas.height - step; y += step) {
          for (let x = step; x < canvas.width - step; x += step) {
            const idx = (y * canvas.width + x) * 4;
            
            // Calculate luminance
            const lum = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
            
            // Sample neighboring pixels for edge detection
            const lumTop = 0.299 * data[idx - canvas.width * 4] + 0.587 * data[idx - canvas.width * 4 + 1] + 0.114 * data[idx - canvas.width * 4 + 2];
            const lumBottom = 0.299 * data[idx + canvas.width * 4] + 0.587 * data[idx + canvas.width * 4 + 1] + 0.114 * data[idx + canvas.width * 4 + 2];
            const lumLeft = 0.299 * data[idx - 4] + 0.587 * data[idx - 3] + 0.114 * data[idx - 2];
            const lumRight = 0.299 * data[idx + 4] + 0.587 * data[idx + 5] + 0.114 * data[idx + 6];
            
            // Edge strength
            const edgeX = Math.abs(lumRight - lumLeft);
            const edgeY = Math.abs(lumBottom - lumTop);
            const edgeStrength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);
            
            // Only keep bright edges
            if (lum > 120 && edgeStrength > 30) {
              points.push({
                x: x,
                y: y,
                brightness: Math.min(1, lum / 255)
              });
            }
          }
        }
        
        // Limit to ~150 brightest points for performance
        return points
          .sort((a, b) => b.brightness - a.brightness)
          .slice(0, 150);
      }
    });
  </script>
  <script>
    // Window and sticky note drag functionality
    function makeDraggable(element) {
      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;

      const header = element.querySelector('.window-header') || element.querySelector('.sticky-note-header');
      
      if (header) {
        header.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
      }

      function dragStart(e) {
        const rect = element.getBoundingClientRect();
        initialX = e.clientX - rect.left;
        initialY = e.clientY - rect.top;
        isDragging = true;
      }

      function drag(e) {
        if (isDragging) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;

          element.style.left = currentX + 'px';
          element.style.top = currentY + 'px';
          element.style.right = 'auto';
        }
      }

      function dragEnd(e) {
        isDragging = false;
      }
    }

    // Make window draggable
    const aboutWindow = document.getElementById('aboutWindow');
    if (aboutWindow) {
      makeDraggable(aboutWindow);
      
      // Add close functionality to red dot
      const redDot = aboutWindow.querySelector('.dot.red');
      if (redDot) {
        redDot.addEventListener('click', () => {
          aboutWindow.style.display = 'none';
        });
      }
    }

    // Make notes window draggable
    const notesWindow = document.getElementById('notesWindow');
    if (notesWindow) {
      makeDraggable(notesWindow);
      
      // Add close functionality to red dot
      const redDot = notesWindow.querySelector('.dot.red');
      if (redDot) {
        redDot.addEventListener('click', () => {
          notesWindow.style.display = 'none';
        });
      }
    }

    // Make Kurrently window draggable
    const kurrentlyWindow = document.getElementById('kurrentlyWindow');
    if (kurrentlyWindow) {
      makeDraggable(kurrentlyWindow);
      
      // Add close functionality to red dot
      const redDot = kurrentlyWindow.querySelector('.dot.red');
      if (redDot) {
        redDot.addEventListener('click', () => {
          kurrentlyWindow.style.display = 'none';
        });
      }
    }

    // Make sticky notes draggable
    document.querySelectorAll('.sticky-note').forEach(note => {
      makeDraggable(note);
    });

    // Hide windows when navigating away and restore on return
    // Store visibility state in sessionStorage
    const storeWindowState = () => {
      if (aboutWindow) {
        sessionStorage.setItem('aboutWindowVisible', aboutWindow.style.display !== 'none');
      }
      if (notesWindow) {
        sessionStorage.setItem('notesWindowVisible', notesWindow.style.display !== 'none');
      }
      if (kurrentlyWindow) {
        sessionStorage.setItem('kurrentlyWindowVisible', kurrentlyWindow.style.display !== 'none');
      }
    };

    // Hide windows when clicking navigation links
    document.querySelectorAll('nav a').forEach(link => {
      link.addEventListener('click', (e) => {
        const href = link.getAttribute('href');
        // Only hide if navigating to different pages (not home)
        if (href && href !== '/' && href !== '/index.html' && !href.startsWith('#')) {
          storeWindowState();
          if (aboutWindow) aboutWindow.style.display = 'none';
          if (notesWindow) notesWindow.style.display = 'none';
          if (kurrentlyWindow) kurrentlyWindow.style.display = 'none';
        }
      });
    });

    // Restore visibility when page loads (only on homepage)
    window.addEventListener('load', () => {
      const aboutVisible = sessionStorage.getItem('aboutWindowVisible');
      const notesVisible = sessionStorage.getItem('notesWindowVisible');
      const kurrentlyVisible = sessionStorage.getItem('kurrentlyWindowVisible');
      
      // If states exist, restore them, otherwise show by default
      if (aboutWindow) {
        aboutWindow.style.display = aboutVisible === 'false' ? 'none' : 'block';
      }
      if (notesWindow) {
        notesWindow.style.display = notesVisible === 'false' ? 'none' : 'block';
      }
      if (kurrentlyWindow) {
        kurrentlyWindow.style.display = kurrentlyVisible === 'false' ? 'none' : 'block';
      }

      // Start Kurrently typing animation
      startKurrentlyAnimation();

      // Fade out Me.txt and Context.txt after 20 seconds
      function startWindowsFadeLoop() {
        const aboutWindow = document.getElementById('aboutWindow');
        const notesWindow = document.getElementById('notesWindow');
        
        if (!aboutWindow || !notesWindow) return;

        // Make sure they start visible
        aboutWindow.style.display = 'block';
        notesWindow.style.display = 'block';

        let fadeTimeout;

        // Function to wake windows up and restart the 20s clock
        function resetFadeTimer() {
          aboutWindow.classList.remove('faded');
          notesWindow.classList.remove('faded');

          clearTimeout(fadeTimeout);

          // After 20 seconds of no interaction, add the faded class back
          fadeTimeout = setTimeout(() => {
            aboutWindow.classList.add('faded');
            notesWindow.classList.add('faded');
          }, 20000); 
        }

        // Start the timer when the script runs
        resetFadeTimer();

        // If the user hovers, clear the timer so it doesn't fade while they read
        [aboutWindow, notesWindow].forEach(win => {
          win.addEventListener('mouseenter', () => {
            clearTimeout(fadeTimeout);
            win.classList.remove('faded'); // Wake it up instantly
          });
          
          // When the mouse leaves, start the 20-second countdown again
          win.addEventListener('mouseleave', resetFadeTimer);
        });
      }

      startWindowsFadeLoop();

      // Font randomization for titles (Kumachi and Kommunity Kamera)
      const TITLE_FONTS = [
        'Bad Unicorn', 'Bajareczka', 'Bajareczka Shadow', 'Bananas', 'Biloxi Script',
        'Cookie Monster', 'Darlington', 'Feijoada', 'Flight of the Ocean', 'Halimun',
        'Hello Ketta', 'Honeybee', 'Koenigsberg', 'Lovely Home', 'Oogie Boogie',
        'Sweet Getaway', 'Tiki Tropic', 'Tiki Tropic Bold', 'Tiki Tropic Outline',
        'Tomatoes', 'Wedding Day', 'Xiomara', 'Yokelvision'
      ];

      function startTitleFontRandomization() {
        const kumachiTitle = document.getElementById('kumachi-title');
        const kameraTitle = document.getElementById('kommunity-kamera-title');
        const yourText = document.getElementById('your-text');
        const myText = document.getElementById('my-text');

        function randomizeTitle(titleElement) {
          if (!titleElement) return;
          
          const text = titleElement.textContent;
          let html = '';
          
          for (let i = 0; i < text.length; i++) {
            const randomFont = TITLE_FONTS[Math.floor(Math.random() * TITLE_FONTS.length)];
            html += `<span style="font-family: '${randomFont}', serif; display: inline-block;">${text[i]}</span>`;
          }
          
          titleElement.innerHTML = html;
        }

        // Randomize every 4 seconds
        setInterval(() => {
          randomizeTitle(kumachiTitle);
          randomizeTitle(kameraTitle);
          randomizeTitle(yourText);
          randomizeTitle(myText);
        }, 4000);

        // Initial randomization
        randomizeTitle(kumachiTitle);
        randomizeTitle(kameraTitle);
        randomizeTitle(yourText);
        randomizeTitle(myText);
      }

      startTitleFontRandomization();
    });
  </script>
  
  <script src="/js/kurrently.js"></script>
  
  <style>
    /* Allow tooltips to escape window boundaries */
    .window-body {
      overflow: visible !important;
    }
    
    .about-text {
      overflow: visible !important;
    }
    
    .tooltip-word {
      position: relative;
      text-decoration: underline;
      text-decoration-color: var(--accent, #8b5cf6);
      text-decoration-thickness: 2px;
      text-underline-offset: 3px;
      cursor: help;
      color: var(--accent, #8b5cf6);
      font-weight: 600;
      display: inline-block;
    }
    
    .tooltip-popup {
      position: fixed;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.98), rgba(109, 40, 217, 0.98));
      color: #ffffff;
      padding: 20px 24px;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 500;
      white-space: normal;
      min-width: 320px;
      max-width: 400px;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
      box-shadow: 0 12px 32px rgba(139, 92, 246, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
      z-index: 10000;
      line-height: 1.5;
      letter-spacing: 0.3px;
      backdrop-filter: blur(10px);
      transform: translateY(-10px);
    }
    
    .tooltip-popup::after {
      content: '';
      position: absolute;
      border: 8px solid transparent;
    }
    
    /* Arrow pointing down (tooltip above) */
    .tooltip-popup.above::after {
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-top-color: rgba(109, 40, 217, 0.98);
    }
    
    /* Arrow pointing up (tooltip below) */
    .tooltip-popup.below::after {
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-bottom-color: rgba(109, 40, 217, 0.98);
    }
    
    .tooltip-word:hover .tooltip-popup {
      opacity: 1;
      visibility: visible;
    }
  </style>
  
  <script>
    // Smart tooltip positioning
    document.addEventListener('DOMContentLoaded', () => {
      const tooltipWords = document.querySelectorAll('.tooltip-word');
      
      tooltipWords.forEach(word => {
        word.addEventListener('mouseenter', function(e) {
          const tooltip = this.querySelector('.tooltip-popup');
          if (!tooltip) return;
          
          const rect = this.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();
          const viewportHeight = window.innerHeight;
          const viewportWidth = window.innerWidth;
          
          // Calculate space above and below
          const spaceAbove = rect.top;
          const spaceBelow = viewportHeight - rect.bottom;
          
          // Determine if tooltip should be above or below
          const showAbove = spaceAbove > spaceBelow || spaceAbove > 200;
          
          // Position horizontally centered on the word
          let left = rect.left + (rect.width / 2);
          
          // Adjust if tooltip would go off screen horizontally
          const tooltipWidth = tooltipRect.width || 360; // fallback width
          if (left - tooltipWidth / 2 < 10) {
            left = tooltipWidth / 2 + 10;
          } else if (left + tooltipWidth / 2 > viewportWidth - 10) {
            left = viewportWidth - tooltipWidth / 2 - 10;
          }
          
          tooltip.style.left = left + 'px';
          
          if (showAbove) {
            tooltip.style.top = (rect.top - 20) + 'px';
            tooltip.style.transform = 'translate(-50%, -100%)';
            tooltip.classList.add('above');
            tooltip.classList.remove('below');
          } else {
            tooltip.style.top = (rect.bottom + 20) + 'px';
            tooltip.style.transform = 'translate(-50%, 0)';
            tooltip.classList.add('below');
            tooltip.classList.remove('above');
          }
        });
      });
    });
  </script>

  <!-- Emoji Picker Modal -->
  <div id="emoji-picker-modal" class="emoji-picker-modal">
    <div class="emoji-picker-content">
      <div class="emoji-picker-header">
        <h3>Select Emoji</h3>
        <button class="emoji-close-btn" onclick="closeEmojiPicker()">&times;</button>
      </div>
      <div class="emoji-categories">
        <button class="emoji-cat-btn active" data-category="smileys">üòä</button>
        <button class="emoji-cat-btn" data-category="hearts">‚ù§Ô∏è</button>
        <button class="emoji-cat-btn" data-category="hands">üëç</button>
        <button class="emoji-cat-btn" data-category="activities">‚öΩ</button>
        <button class="emoji-cat-btn" data-category="objects">üí°</button>
        <button class="emoji-cat-btn" data-category="symbols">‚ú®</button>
        <button class="emoji-cat-btn" data-category="nature">üå∏</button>
        <button class="emoji-cat-btn" data-category="food">üçï</button>
      </div>
      <div class="emoji-grid" id="emojiGrid"></div>
    </div>
  </div>

  <script src="/js/emoji-picker.js"></script>
  
  <script>
    // Drawing canvas functionality
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    const drawColorInput = document.getElementById('drawColor');
    const clearCanvasBtn = document.getElementById('clearCanvasBtn');
    const useDrawingBtn = document.getElementById('useDrawingBtn');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    // Initialize canvas background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Get canvas position
    function getCanvasPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || e.touches[0].clientX) - rect.left;
      const y = (e.clientY || e.touches[0].clientY) - rect.top;
      return { x, y };
    }

    // Start drawing
    function startDrawing(e) {
      isDrawing = true;
      const pos = getCanvasPos(e);
      lastX = pos.x;
      lastY = pos.y;
      e.preventDefault();
    }

    // Draw
    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      
      const pos = getCanvasPos(e);
      ctx.strokeStyle = drawColorInput.value;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      
      lastX = pos.x;
      lastY = pos.y;
    }

    // Stop drawing
    function stopDrawing(e) {
      isDrawing = false;
      e.preventDefault();
    }

    // Canvas events
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    // Touch events for mobile
    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', stopDrawing);

    // Clear canvas
    clearCanvasBtn.addEventListener('click', () => {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    });

    // Use drawing as photo
    useDrawingBtn.addEventListener('click', () => {
      const drawingData = canvas.toDataURL('image/png');
      
      // Store drawing data in a hidden input to be picked up by form submission
      let drawingInput = document.getElementById('userDrawing');
      if (!drawingInput) {
        drawingInput = document.createElement('input');
        drawingInput.type = 'hidden';
        drawingInput.id = 'userDrawing';
        document.getElementById('globe-form').appendChild(drawingInput);
      }
      drawingInput.value = drawingData;
      
      alert('Drawing saved! It will be submitted with your message.');
      clearCanvasBtn.click();
    });

    // Update form submission to include drawing
    const globeForm = document.getElementById('globe-form');
    const originalHandleFormSubmit = window.handleFormSubmit;
    globeForm.addEventListener('submit', (e) => {
      const drawingInput = document.getElementById('userDrawing');
      if (drawingInput && drawingInput.value) {
        // Override the form submission to include the drawing
        e.preventDefault();
        e.stopImmediatePropagation();
        
        const name = document.getElementById('userName').value.trim();
        const text = document.getElementById('weekFeeling').value.trim();
        const textColor = document.getElementById('textColor').value;
        const bgColor = document.getElementById('bgColor').value;
        const userFont = document.getElementById('userFont').value;
        const drawingData = drawingInput.value;
        
        if (!name || !text) {
          alert('Please enter a name and message');
          return;
        }
        
        // Disable submit button during processing
        const submitBtn = document.querySelector('#globe-form button[type="submit"]');
        if (submitBtn) submitBtn.disabled = true;
        
        // Save entry with drawing data
        saveNewEntry(name, text, null, textColor, bgColor, userFont, drawingData, submitBtn);
        
        // Clear drawing input after submission
        drawingInput.value = '';
      }
    }, true);
  </script>

  <!-- Twitter/X embed widget -->
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</body>
</html>